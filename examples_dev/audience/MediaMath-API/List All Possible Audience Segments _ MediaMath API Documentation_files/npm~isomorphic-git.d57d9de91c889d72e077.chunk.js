(self.webpackJsonp=self.webpackJsonp||[]).push([[30],{1096:function(t,e){function i(t){return class extends Error{constructor(...e){super(...e),this.code=t,this.message?this.message=t+": "+this.message:this.message=t}}}const r=i("EEXIST"),s=i("ENOENT"),n=i("ENOTDIR"),a=i("ENOTEMPTY"),o=i("ETIMEDOUT");t.exports={EEXIST:r,ENOENT:s,ENOTDIR:n,ENOTEMPTY:a,ETIMEDOUT:o}},1097:function(t,e,i){"use strict";i.r(e),i.d(e,"Store",(function(){return r})),i.d(e,"get",(function(){return a})),i.d(e,"set",(function(){return o})),i.d(e,"update",(function(){return c})),i.d(e,"del",(function(){return d})),i.d(e,"clear",(function(){return l})),i.d(e,"keys",(function(){return h})),i.d(e,"close",(function(){return f}));class r{constructor(t="keyval-store",e="keyval"){this.storeName=e,this._dbName=t,this._storeName=e,this._init()}_init(){this._dbp||(this._dbp=new Promise((t,e)=>{const i=indexedDB.open(this._dbName);i.onerror=()=>e(i.error),i.onsuccess=()=>t(i.result),i.onupgradeneeded=()=>{i.result.createObjectStore(this._storeName)}}))}_withIDBStore(t,e){return this._init(),this._dbp.then(i=>new Promise((r,s)=>{const n=i.transaction(this.storeName,t);n.oncomplete=()=>r(),n.onabort=n.onerror=()=>s(n.error),e(n.objectStore(this.storeName))}))}_close(){return this._init(),this._dbp.then(t=>{t.close(),this._dbp=void 0})}}let s;function n(){return s||(s=new r),s}function a(t,e=n()){let i;return e._withIDBStore("readwrite",e=>{i=e.get(t)}).then(()=>i.result)}function o(t,e,i=n()){return i._withIDBStore("readwrite",i=>{i.put(e,t)})}function c(t,e,i=n()){return i._withIDBStore("readwrite",i=>{const r=i.get(t);r.onsuccess=()=>{i.put(e(r.result),t)}})}function d(t,e=n()){return e._withIDBStore("readwrite",e=>{e.delete(t)})}function l(t=n()){return t._withIDBStore("readwrite",t=>{t.clear()})}function h(t=n()){const e=[];return t._withIDBStore("readwrite",t=>{(t.openKeyCursor||t.openCursor).call(t).onsuccess=function(){this.result&&(e.push(this.result.key),this.result.continue())}}).then(()=>e)}function f(t=n()){return t._close()}},1208:function(t,e,i){(function(e){function i(t){return Array.isArray(t)?t:[t]}const r=/^\s+$/,s=/^\\!/,n=/^\\#/,a=/\r?\n/g,o=/^\.*\/|^\.+$/,c="undefined"!=typeof Symbol?Symbol.for("node-ignore"):"node-ignore",d=/([0-z])-([0-z])/g,l=[[/\\?\s+$/,t=>0===t.indexOf("\\")?" ":""],[/\\\s/g,()=>" "],[/[\\^$.|*+(){]/g,t=>"\\"+t],[/\[([^\]/]*)($|\])/g,(t,e,i)=>{return"]"===i?`[${r=e,r.replace(d,(t,e,i)=>e.charCodeAt(0)<=i.charCodeAt(0)?t:"")}]`:"\\"+t;var r}],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/(?:[^*])$/,t=>/\/$/.test(t)?t+"$":t+"(?=$|\\/$)"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(t,e,i)=>e+6<i.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)\\\*(?=.+)/g,(t,e)=>e+"[^\\/]*"],[/(\^|\\\/)?\\\*$/,(t,e)=>(e?e+"[^/]+":"[^/]*")+"(?=$|\\/$)"],[/\\\\\\/g,()=>"\\"]],h=Object.create(null),f=t=>"string"==typeof t;class u{constructor(t,e,i,r){this.origin=t,this.pattern=e,this.negative=i,this.regex=r}}const p=(t,e)=>{const i=t;let r=!1;0===t.indexOf("!")&&(r=!0,t=t.substr(1));const a=((t,e,i)=>{const r=h[t];if(r)return r;const s=l.reduce((e,i)=>e.replace(i[0],i[1].bind(t)),t);return h[t]=i?new RegExp(s,"i"):new RegExp(s)})(t=t.replace(s,"!").replace(n,"#"),0,e);return new u(i,t,r,a)},m=(t,e)=>{throw new e(t)},w=(t,e,i)=>{if(!f(t))return i(`path must be a string, but got \`${e}\``,TypeError);if(!t)return i("path must not be empty",TypeError);if(w.isNotRelative(t)){return i(`path should be a ${"`path.relative()`d"} string, but got "${e}"`,RangeError)}return!0},g=t=>o.test(t);w.isNotRelative=g,w.convert=t=>t;class y{constructor({ignorecase:t=!0}={}){var e,i,r;this._rules=[],this._ignorecase=t,e=this,i=c,r=!0,Object.defineProperty(e,i,{value:r}),this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(t){if(t&&t[c])return this._rules=this._rules.concat(t._rules),void(this._added=!0);if((t=>t&&f(t)&&!r.test(t)&&0!==t.indexOf("#"))(t)){const e=p(t,this._ignorecase);this._added=!0,this._rules.push(e)}}add(t){return this._added=!1,i(f(t)?(t=>t.split(a))(t):t).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(t){return this.add(t)}_testOne(t,e){let i=!1,r=!1;return this._rules.forEach(s=>{const{negative:n}=s;if(r===n&&i!==r||n&&!i&&!r&&!e)return;s.regex.test(t)&&(i=!n,r=n)}),{ignored:i,unignored:r}}_test(t,e,i,r){const s=t&&w.convert(t);return w(s,t,m),this._t(s,e,i,r)}_t(t,e,i,r){if(t in e)return e[t];if(r||(r=t.split("/")),r.pop(),!r.length)return e[t]=this._testOne(t,i);const s=this._t(r.join("/")+"/",e,i,r);return e[t]=s.ignored?s:this._testOne(t,i)}ignores(t){return this._test(t,this._ignoreCache,!1).ignored}createFilter(){return t=>!this.ignores(t)}filter(t){return i(t).filter(this.createFilter())}test(t){return this._test(t,this._testCache,!0)}}const b=t=>new y(t),_=()=>!1;if(b.isPathValid=t=>w(t&&w.convert(t),t,_),b.default=b,t.exports=b,void 0!==e&&(e.env&&e.env.IGNORE_TEST_WIN32||"win32"===e.platform)){const t=t=>/^\\\\\?\\/.test(t)||/["<>|\u0000-\u001F]+/u.test(t)?t:t.replace(/\\/g,"/");w.convert=t;const e=/^[a-z]:\//i;w.isNotRelative=t=>e.test(t)||g(t)}}).call(this,i(67))},1238:function(t,e,i){const r=i(1923),s=i(1924);function n(t,e){"function"==typeof t&&(e=t);return[(...t)=>e(null,...t),e=r(e)]}t.exports=class{constructor(...t){this.promises=new s(...t),this.init=this.init.bind(this),this.readFile=this.readFile.bind(this),this.writeFile=this.writeFile.bind(this),this.unlink=this.unlink.bind(this),this.readdir=this.readdir.bind(this),this.mkdir=this.mkdir.bind(this),this.rmdir=this.rmdir.bind(this),this.rename=this.rename.bind(this),this.stat=this.stat.bind(this),this.lstat=this.lstat.bind(this),this.readlink=this.readlink.bind(this),this.symlink=this.symlink.bind(this),this.backFile=this.backFile.bind(this),this.du=this.du.bind(this)}init(t,e){return this.promises.init(t,e)}readFile(t,e,i){const[r,s]=n(e,i);this.promises.readFile(t,e).then(r).catch(s)}writeFile(t,e,i,r){const[s,a]=n(i,r);this.promises.writeFile(t,e,i).then(s).catch(a)}unlink(t,e,i){const[r,s]=n(e,i);this.promises.unlink(t,e).then(r).catch(s)}readdir(t,e,i){const[r,s]=n(e,i);this.promises.readdir(t,e).then(r).catch(s)}mkdir(t,e,i){const[r,s]=n(e,i);this.promises.mkdir(t,e).then(r).catch(s)}rmdir(t,e,i){const[r,s]=n(e,i);this.promises.rmdir(t,e).then(r).catch(s)}rename(t,e,i){const[r,s]=n(i);this.promises.rename(t,e).then(r).catch(s)}stat(t,e,i){const[r,s]=n(e,i);this.promises.stat(t).then(r).catch(s)}lstat(t,e,i){const[r,s]=n(e,i);this.promises.lstat(t).then(r).catch(s)}readlink(t,e,i){const[r,s]=n(e,i);this.promises.readlink(t).then(r).catch(s)}symlink(t,e,i){const[r,s]=n(i);this.promises.symlink(t,e).then(r).catch(s)}backFile(t,e,i){const[r,s]=n(e,i);this.promises.backFile(t,e).then(r).catch(s)}du(t,e){const[i,r]=n(e);this.promises.du(t).then(i).catch(r)}}},1924:function(t,e,i){const r=i(1925),s=i(1933),n=i(742);function a(t,e,...i){return void 0!==e&&"function"!=typeof e||(e={}),"string"==typeof e&&(e={encoding:e}),[t=n.normalize(t),e,...i]}function o(t,e,i,...r){return void 0!==i&&"function"!=typeof i||(i={}),"string"==typeof i&&(i={encoding:i}),[t=n.normalize(t),e,i,...r]}function c(t,e,...i){return[n.normalize(t),n.normalize(e),...i]}t.exports=class{constructor(t,e={}){this.init=this.init.bind(this),this.readFile=this._wrap(this.readFile,a,!1),this.writeFile=this._wrap(this.writeFile,o,!0),this.unlink=this._wrap(this.unlink,a,!0),this.readdir=this._wrap(this.readdir,a,!1),this.mkdir=this._wrap(this.mkdir,a,!0),this.rmdir=this._wrap(this.rmdir,a,!0),this.rename=this._wrap(this.rename,c,!0),this.stat=this._wrap(this.stat,a,!1),this.lstat=this._wrap(this.lstat,a,!1),this.readlink=this._wrap(this.readlink,a,!1),this.symlink=this._wrap(this.symlink,c,!0),this.backFile=this._wrap(this.backFile,a,!0),this.du=this._wrap(this.du,a,!1),this._deactivationPromise=null,this._deactivationTimeout=null,this._activationPromise=null,this._operations=new Set,t&&this.init(t,e)}async init(...t){return this._initPromiseResolve&&await this._initPromise,this._initPromise=this._init(...t),this._initPromise}async _init(t,e={}){await this._gracefulShutdown(),this._activationPromise&&await this._deactivate(),this._backend&&this._backend.destroy&&await this._backend.destroy(),this._backend=e.backend||new r,this._backend.init&&await this._backend.init(t,e),this._initPromiseResolve&&(this._initPromiseResolve(),this._initPromiseResolve=null),e.defer||this.stat("/")}async _gracefulShutdown(){this._operations.size>0&&(this._isShuttingDown=!0,await new Promise(t=>this._gracefulShutdownResolve=t),this._isShuttingDown=!1,this._gracefulShutdownResolve=null)}_wrap(t,e,i){return async(...r)=>{r=e(...r);let s={name:t.name,args:r};this._operations.add(s);try{return await this._activate(),await t.apply(this,r)}finally{this._operations.delete(s),i&&this._backend.saveSuperblock(),0===this._operations.size&&(this._deactivationTimeout||clearTimeout(this._deactivationTimeout),this._deactivationTimeout=setTimeout(this._deactivate.bind(this),500))}}}async _activate(){this._initPromise||console.warn(new Error(`Attempted to use LightningFS ${this._name} before it was initialized.`)),await this._initPromise,this._deactivationTimeout&&(clearTimeout(this._deactivationTimeout),this._deactivationTimeout=null),this._deactivationPromise&&await this._deactivationPromise,this._deactivationPromise=null,this._activationPromise||(this._activationPromise=this._backend.activate?this._backend.activate():Promise.resolve()),await this._activationPromise}async _deactivate(){return this._activationPromise&&await this._activationPromise,this._deactivationPromise||(this._deactivationPromise=this._backend.deactivate?this._backend.deactivate():Promise.resolve()),this._activationPromise=null,this._gracefulShutdownResolve&&this._gracefulShutdownResolve(),this._deactivationPromise}async readFile(t,e){return this._backend.readFile(t,e)}async writeFile(t,e,i){return await this._backend.writeFile(t,e,i),null}async unlink(t,e){return await this._backend.unlink(t,e),null}async readdir(t,e){return this._backend.readdir(t,e)}async mkdir(t,e){return await this._backend.mkdir(t,e),null}async rmdir(t,e){return await this._backend.rmdir(t,e),null}async rename(t,e){return await this._backend.rename(t,e),null}async stat(t,e){const i=await this._backend.stat(t,e);return new s(i)}async lstat(t,e){const i=await this._backend.lstat(t,e);return new s(i)}async readlink(t,e){return this._backend.readlink(t,e)}async symlink(t,e){return await this._backend.symlink(t,e),null}async backFile(t,e){return await this._backend.backFile(t,e),null}async du(t){return this._backend.du(t)}}},1925:function(t,e,i){const{encode:r,decode:s}=i(1227),n=i(1927),a=i(1928),{ENOENT:o,ENOTEMPTY:c,ETIMEDOUT:d}=i(1096),l=i(1929),h=i(1930),f=i(1931),u=i(1932),p=i(742);t.exports=class{constructor(){this.saveSuperblock=n(()=>{this._saveSuperblock()},500)}async init(t,{wipe:e,url:i,urlauto:r,fileDbName:s=t,fileStoreName:n=t+"_files",lockDbName:o=t+"_lock",lockStoreName:c=t+"_lock"}={}){this._name=t,this._idb=new l(s,n),this._mutex=navigator.locks?new u(t):new f(o,c),this._cache=new a(t),this._opts={wipe:e,url:i},this._needsWipe=!!e,i&&(this._http=new h(i),this._urlauto=!!r)}async activate(){if(this._cache.activated)return;this._needsWipe&&(this._needsWipe=!1,await this._idb.wipe(),await this._mutex.release({force:!0})),await this._mutex.has()||await this._mutex.wait();const t=await this._idb.loadSuperblock();if(t)this._cache.activate(t);else if(this._http){const t=await this._http.loadSuperblock();this._cache.activate(t),await this._saveSuperblock()}else this._cache.activate();if(!await this._mutex.has())throw new d}async deactivate(){await this._mutex.has()&&await this._saveSuperblock(),this._cache.deactivate();try{await this._mutex.release()}catch(t){console.log(t)}await this._idb.close()}async _saveSuperblock(){this._cache.activated&&(this._lastSavedAt=Date.now(),await this._idb.saveSuperblock(this._cache._root))}_writeStat(t,e,i){let r=p.split(p.dirname(t)),s=r.shift();for(let t of r){s=p.join(s,t);try{this._cache.mkdir(s,{mode:511})}catch(t){}}return this._cache.writeStat(t,e,i)}async readFile(t,e){const{encoding:i}=e;if(i&&"utf8"!==i)throw new Error('Only "utf8" encoding is supported in readFile');let r=null,n=null;try{n=this._cache.stat(t),r=await this._idb.readFile(n.ino)}catch(t){if(!this._urlauto)throw t}if(!r&&this._http){let e=this._cache.lstat(t);for(;"symlink"===e.type;)t=p.resolve(p.dirname(t),e.target),e=this._cache.lstat(t);r=await this._http.readFile(t)}if(r&&(n&&n.size==r.byteLength||(n=await this._writeStat(t,r.byteLength,{mode:n?n.mode:438}),this.saveSuperblock()),"utf8"===i&&(r=s(r))),!n)throw new o(t);return r}async writeFile(t,e,i){const{mode:s,encoding:n="utf8"}=i;if("string"==typeof e){if("utf8"!==n)throw new Error('Only "utf8" encoding is supported in writeFile');e=r(e)}const a=await this._cache.writeStat(t,e.byteLength,{mode:s});await this._idb.writeFile(a.ino,e)}async unlink(t,e){const i=this._cache.lstat(t);this._cache.unlink(t),"symlink"!==i.type&&await this._idb.unlink(i.ino)}readdir(t,e){return this._cache.readdir(t)}mkdir(t,e){const{mode:i=511}=e;this._cache.mkdir(t,{mode:i})}rmdir(t,e){if("/"===t)throw new c;this._cache.rmdir(t)}rename(t,e){this._cache.rename(t,e)}stat(t,e){return this._cache.stat(t)}lstat(t,e){return this._cache.lstat(t)}readlink(t,e){return this._cache.readlink(t)}symlink(t,e){this._cache.symlink(t,e)}async backFile(t,e){let i=await this._http.sizeFile(t);await this._writeStat(t,i,e)}du(t){return this._cache.du(t)}}},1928:function(t,e,i){const r=i(742),{EEXIST:s,ENOENT:n,ENOTDIR:a,ENOTEMPTY:o}=i(1096);t.exports=class{constructor(){}_makeRoot(t=new Map){return t.set(0,{mode:511,type:"dir",size:0,ino:0,mtimeMs:Date.now()}),t}activate(t=null){this._root=null===t?new Map([["/",this._makeRoot()]]):"string"==typeof t?new Map([["/",this._makeRoot(this.parse(t))]]):t}get activated(){return!!this._root}deactivate(){this._root=void 0}size(){return this._countInodes(this._root.get("/"))-1}_countInodes(t){let e=1;for(let[i,r]of t)0!==i&&(e+=this._countInodes(r));return e}autoinc(){return this._maxInode(this._root.get("/"))+1}_maxInode(t){let e=t.get(0).ino;for(let[i,r]of t)0!==i&&(e=Math.max(e,this._maxInode(r)));return e}print(t=this._root.get("/")){let e="";const i=(t,r)=>{for(let[s,n]of t){if(0===s)continue;let t=n.get(0),a=t.mode.toString(8);e+=`${"\t".repeat(r)}${s}\t${a}`,"file"===t.type?e+=`\t${t.size}\t${t.mtimeMs}\n`:(e+="\n",i(n,r+1))}};return i(t,0),e}parse(t){let e=0;function i(t){const i=++e,r=1===t.length?"dir":"file";let[s,n,a]=t;return s=parseInt(s,8),n=n?parseInt(n):0,a=a?parseInt(a):Date.now(),new Map([[0,{mode:s,type:r,size:n,mtimeMs:a,ino:i}]])}let r=t.trim().split("\n"),s=this._makeRoot(),n=[{indent:-1,node:s},{indent:0,node:null}];for(let t of r){let e=t.match(/^\t*/)[0].length;t=t.slice(e);let[r,...s]=t.split("\t"),a=i(s);if(e<=n[n.length-1].indent)for(;e<=n[n.length-1].indent;)n.pop();n.push({indent:e,node:a}),n[n.length-2].node.set(r,a)}return s}_lookup(t,e=!0){let i=this._root,s="/",a=r.split(t);for(let o=0;o<a.length;++o){let c=a[o];if(i=i.get(c),!i)throw new n(t);if(e||o<a.length-1){const t=i.get(0);if("symlink"===t.type){let e=r.resolve(s,t.target);i=this._lookup(e)}s=s?r.join(s,c):c}}return i}mkdir(t,{mode:e}){if("/"===t)throw new s;let i=this._lookup(r.dirname(t)),n=r.basename(t);if(i.has(n))throw new s;let a=new Map,o={mode:e,type:"dir",size:0,mtimeMs:Date.now(),ino:this.autoinc()};a.set(0,o),i.set(n,a)}rmdir(t){let e=this._lookup(t);if("dir"!==e.get(0).type)throw new a;if(e.size>1)throw new o;let i=this._lookup(r.dirname(t)),s=r.basename(t);i.delete(s)}readdir(t){let e=this._lookup(t);if("dir"!==e.get(0).type)throw new a;return[...e.keys()].filter(t=>"string"==typeof t)}writeStat(t,e,{mode:i}){let s;try{let e=this.stat(t);null==i&&(i=e.mode),s=e.ino}catch(t){}null==i&&(i=438),null==s&&(s=this.autoinc());let n=this._lookup(r.dirname(t)),a=r.basename(t),o={mode:i,type:"file",size:e,mtimeMs:Date.now(),ino:s},c=new Map;return c.set(0,o),n.set(a,c),o}unlink(t){let e=this._lookup(r.dirname(t)),i=r.basename(t);e.delete(i)}rename(t,e){let i=r.basename(e),s=this._lookup(t);this._lookup(r.dirname(e)).set(i,s),this.unlink(t)}stat(t){return this._lookup(t).get(0)}lstat(t){return this._lookup(t,!1).get(0)}readlink(t){return this._lookup(t,!1).get(0).target}symlink(t,e){let i,s;try{let t=this.stat(e);null===s&&(s=t.mode),i=t.ino}catch(t){}null==s&&(s=40960),null==i&&(i=this.autoinc());let n=this._lookup(r.dirname(e)),a=r.basename(e),o={mode:s,type:"symlink",target:t,size:0,mtimeMs:Date.now(),ino:i},c=new Map;return c.set(0,o),n.set(a,c),o}_du(t){let e=0;for(const[i,r]of t.entries())e+=0===i?r.size:this._du(r);return e}du(t){let e=this._lookup(t);return this._du(e)}}},1929:function(t,e,i){const r=i(1097);t.exports=class{constructor(t,e){this._database=t,this._storename=e,this._store=new r.Store(this._database,this._storename)}saveSuperblock(t){return r.set("!root",t,this._store)}loadSuperblock(){return r.get("!root",this._store)}readFile(t){return r.get(t,this._store)}writeFile(t,e){return r.set(t,e,this._store)}unlink(t){return r.del(t,this._store)}wipe(){return r.clear(this._store)}close(){return r.close(this._store)}}},193:function(t,e,i){"use strict";const r=(t,e)=>function(...i){return new(0,e.promiseModule)((r,s)=>{e.multiArgs?i.push((...t)=>{e.errorFirst?t[0]?s(t):(t.shift(),r(t)):r(t)}):e.errorFirst?i.push((t,e)=>{t?s(t):r(e)}):i.push(r),t.apply(this,i)})};t.exports=(t,e)=>{e=Object.assign({exclude:[/.+(Sync|Stream)$/],errorFirst:!0,promiseModule:Promise},e);const i=typeof t;if(null===t||"object"!==i&&"function"!==i)throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${null===t?"null":i}\``);const s=t=>{const i=e=>"string"==typeof e?t===e:e.test(t);return e.include?e.include.some(i):!e.exclude.some(i)};let n;n="function"===i?function(...i){return e.excludeMain?t(...i):r(t,e).apply(this,i)}:Object.create(Object.getPrototypeOf(t));for(const i in t){const a=t[i];n[i]="function"==typeof a&&s(i)?r(a,e):a}return n}},1930:function(t,e){t.exports=class{constructor(t){this._url=t}loadSuperblock(){return fetch(this._url+"/.superblock.txt").then(t=>t.ok?t.text():null)}async readFile(t){const e=await fetch(this._url+t);if(200===e.status)return e.arrayBuffer();throw new Error("ENOENT")}async sizeFile(t){const e=await fetch(this._url+t,{method:"HEAD"});if(200===e.status)return e.headers.get("content-length");throw new Error("ENOENT")}}},1931:function(t,e,i){const r=i(1097),s=t=>new Promise(e=>setTimeout(e,t));t.exports=class{constructor(t,e){this._id=Math.random(),this._database=t,this._storename=e,this._store=new r.Store(this._database,this._storename),this._lock=null}async has({margin:t=2e3}={}){if(this._lock&&this._lock.holder===this._id){const e=Date.now();return this._lock.expires>e+t||await this.renew()}return!1}async renew({ttl:t=5e3}={}){let e;return await r.update("lock",i=>{const r=Date.now()+t;return e=i&&i.holder===this._id,this._lock=e?{holder:this._id,expires:r}:i,this._lock},this._store),e}async acquire({ttl:t=5e3}={}){let e,i,s;if(await r.update("lock",r=>{const n=Date.now(),a=n+t;return i=r&&r.expires<n,e=void 0===r||i,s=r&&r.holder===this._id,this._lock=e?{holder:this._id,expires:a}:r,this._lock},this._store),s)throw new Error("Mutex double-locked");return e}async wait({interval:t=100,limit:e=6e3,ttl:i}={}){for(;e--;){if(await this.acquire({ttl:i}))return!0;await s(t)}throw new Error("Mutex timeout")}async release({force:t=!1}={}){let e,i,s;if(await r.update("lock",r=>(e=t||r&&r.holder===this._id,i=void 0===r,s=r&&r.holder!==this._id,this._lock=e?void 0:r,this._lock),this._store),await r.close(this._store),!e&&!t){if(i)throw new Error("Mutex double-freed");if(s)throw new Error("Mutex lost ownership")}return e}}},1932:function(t,e){t.exports=class{constructor(t){this._id=Math.random(),this._database=t,this._has=!1,this._release=null}async has(){return this._has}async acquire(){return new Promise(t=>{navigator.locks.request(this._database+"_lock",{ifAvailable:!0},e=>(this._has=!!e,t(!!e),new Promise(t=>{this._release=t})))})}async wait({timeout:t=6e5}={}){return new Promise((e,i)=>{const r=new AbortController;setTimeout(()=>{r.abort(),i(new Error("Mutex timeout"))},t),navigator.locks.request(this._database+"_lock",{signal:r.signal},t=>(this._has=!!t,e(!!t),new Promise(t=>{this._release=t})))})}async release({force:t=!1}={}){this._has=!1,this._release?this._release():t&&navigator.locks.request(this._database+"_lock",{steal:!0},t=>!0)}}},1933:function(t,e){t.exports=class{constructor(t){this.type=t.type,this.mode=t.mode,this.size=t.size,this.ino=t.ino,this.mtimeMs=t.mtimeMs,this.ctimeMs=t.ctimeMs||t.mtimeMs,this.uid=1,this.gid=1,this.dev=1}isFile(){return"file"===this.type}isDirectory(){return"dir"===this.type}isSymbolicLink(){return"symlink"===this.type}}},2047:function(t,e,i){"use strict";(function(t){i.d(e,"a",(function(){return se})),i.d(e,"b",(function(){return Ee})),i.d(e,"c",(function(){return Re})),i.d(e,"d",(function(){return Ae})),i.d(e,"e",(function(){return Be})),i.d(e,"f",(function(){return mi})),i.d(e,"g",(function(){return wi})),i.d(e,"h",(function(){return xi})),i.d(e,"i",(function(){return Ei})),i.d(e,"j",(function(){return Si})),i.d(e,"k",(function(){return Pi})),i.d(e,"l",(function(){return Ii})),i.d(e,"m",(function(){return ji})),i.d(e,"n",(function(){return Ni})),i.d(e,"o",(function(){return Di})),i.d(e,"p",(function(){return Mi})),i.d(e,"q",(function(){return Ti})),i.d(e,"r",(function(){return Bi})),i.d(e,"s",(function(){return Fi})),i.d(e,"t",(function(){return zi})),i.d(e,"u",(function(){return Hi})),i.d(e,"v",(function(){return Gi})),i.d(e,"w",(function(){return Wi}));var r=i(798),s=i.n(r),n=i(600),a=i.n(n),o=i(1239),c=i.n(o),d=i(799),l=i.n(d),h=i(1208),f=i.n(h),u=i(193),p=i.n(u),m=i(245),w=i.n(m),g=i(2016),y=i.n(g);class b extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new b(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class _ extends b{constructor(t){super("An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: "+t),this.code=this.name=_.code,this.data={message:t}}}_.code="InternalError";class v extends b{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=v.code,this.data={filepath:t}}}v.code="UnsafeFilepathError";class k{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const i=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,i}write(t,e,i){const r=this.buffer.write(t,this._start,e,i);return this._start+=e,r}copy(t,e,i){const r=t.copy(this.buffer,this._start,e,i);return this._start+=r,r}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function x(t,e){return-(t<e)||+(t>e)}function E(t,e){return x(t.path,e.path)}function $(t){let e=t>0?t>>12:0;4!==e&&8!==e&&10!==e&&14!==e&&(e=8);let i=511&t;return i=73&i?493:420,8!==e&&(i=0),(e<<12)+i}function S(t,e,i,r){if(void 0!==t&&void 0!==e)return[t,e];void 0===i&&(i=r.valueOf());const s=Math.floor(i/1e3);return[s,1e6*(i-1e3*s)]}function P(t){const[e,i]=S(t.ctimeSeconds,t.ctimeNanoseconds,t.ctimeMs,t.ctime),[r,s]=S(t.mtimeSeconds,t.mtimeNanoseconds,t.mtimeMs,t.mtime);return{ctimeSeconds:e%2**32,ctimeNanoseconds:i%2**32,mtimeSeconds:r%2**32,mtimeNanoseconds:s%2**32,dev:t.dev%2**32,ino:t.ino%2**32,mode:$(t.mode%2**32),uid:t.uid%2**32,gid:t.gid%2**32,size:t.size>-1?t.size%2**32:0}}let I=null;async function j(t){return null===I&&(I=await async function(){try{if("da39a3ee5e6b4b0d3255bfef95601890afd80709"===await O(new Uint8Array([])))return!0}catch(t){}return!1}()),I?O(t):function(t){return(new a.a).update(t).digest("hex")}(t)}async function O(t){return function(t){let e="";for(const i of new Uint8Array(t))i<16&&(e+="0"),e+=i.toString(16);return e}(await crypto.subtle.digest("SHA-1",t))}class R{constructor(t){this._dirty=!1,this._entries=t||new Map}static async from(e){if(t.isBuffer(e))return R.fromBuffer(e);if(null===e)return new R(null);throw new _("invalid type passed to GitIndex.from")}static async fromBuffer(t){const e=await j(t.slice(0,-20)),i=t.slice(-20).toString("hex");if(i!==e)throw new _(`Invalid checksum in GitIndex buffer: expected ${i} but saw ${e}`);const r=new k(t),s=new Map,n=r.toString("utf8",4);if("DIRC"!==n)throw new _("Inavlid dircache magic file number: "+n);const a=r.readUInt32BE();if(2!==a)throw new _("Unsupported dircache version: "+a);const o=r.readUInt32BE();let c=0;for(;!r.eof()&&c<o;){const e={};e.ctimeSeconds=r.readUInt32BE(),e.ctimeNanoseconds=r.readUInt32BE(),e.mtimeSeconds=r.readUInt32BE(),e.mtimeNanoseconds=r.readUInt32BE(),e.dev=r.readUInt32BE(),e.ino=r.readUInt32BE(),e.mode=r.readUInt32BE(),e.uid=r.readUInt32BE(),e.gid=r.readUInt32BE(),e.size=r.readUInt32BE(),e.oid=r.slice(20).toString("hex");const i=r.readUInt16BE();e.flags=(d=i,{assumeValid:Boolean(32768&d),extended:Boolean(16384&d),stage:(12288&d)>>12,nameLength:4095&d});const n=t.indexOf(0,r.tell()+1)-r.tell();if(n<1)throw new _("Got a path length of: "+n);if(e.path=r.toString("utf8",n),e.path.includes("..\\")||e.path.includes("../"))throw new v(e.path);let a=8-(r.tell()-12)%8;for(0===a&&(a=8);a--;){const t=r.readUInt8();if(0!==t)throw new _(`Expected 1-8 null characters but got '${t}' after ${e.path}`);if(r.eof())throw new _("Unexpected end of file")}s.set(e.path,e),c++}var d;return new R(s)}get entries(){return[...this._entries.values()].sort(E)}get entriesMap(){return this._entries}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:e,stats:i,oid:r}){i=P(i);const s=t.from(e),n={ctimeSeconds:i.ctimeSeconds,ctimeNanoseconds:i.ctimeNanoseconds,mtimeSeconds:i.mtimeSeconds,mtimeNanoseconds:i.mtimeNanoseconds,dev:i.dev,ino:i.ino,mode:i.mode||33188,uid:i.uid,gid:i.gid,size:i.size,path:e,oid:r,flags:{assumeValid:!1,extended:!1,stage:0,nameLength:s.length<4095?s.length:4095}};this._entries.set(n.path,n),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join("\n")}async toObject(){const e=t.alloc(12),i=new k(e);i.write("DIRC",4,"utf8"),i.writeUInt32BE(2),i.writeUInt32BE(this.entries.length);const r=t.concat(this.entries.map(e=>{const i=t.from(e.path),r=8*Math.ceil((62+i.length+1)/8),s=t.alloc(r),n=new k(s),a=P(e);return n.writeUInt32BE(a.ctimeSeconds),n.writeUInt32BE(a.ctimeNanoseconds),n.writeUInt32BE(a.mtimeSeconds),n.writeUInt32BE(a.mtimeNanoseconds),n.writeUInt32BE(a.dev),n.writeUInt32BE(a.ino),n.writeUInt32BE(a.mode),n.writeUInt32BE(a.uid),n.writeUInt32BE(a.gid),n.writeUInt32BE(a.size),n.write(e.oid,20,"hex"),n.writeUInt16BE(function(e){const i=e.flags;return i.extended=!1,i.nameLength=Math.min(t.from(e.path).length,4095),(i.assumeValid?32768:0)+(i.extended?16384:0)+((3&i.stage)<<12)+(4095&i.nameLength)}(e)),n.write(e.path,i.length,"utf8"),s})),s=t.concat([e,r]),n=await j(s);return t.concat([s,t.from(n,"hex")])}}function A(t,e){const i=P(t),r=P(e);return i.mode!==r.mode||i.mtimeSeconds!==r.mtimeSeconds||i.ctimeSeconds!==r.ctimeSeconds||i.uid!==r.uid||i.gid!==r.gid||i.ino!==r.ino||i.size!==r.size}let N=null;const D=Symbol("IndexCache");class U{static async acquire({fs:t,gitdir:e,cache:i},r){i[D]||(i[D]={map:new Map,stats:new Map});const n=e+"/index";let a;return null===N&&(N=new s.a({maxPending:1/0})),await N.acquire(n,async()=>{await async function(t,e,i){const r=i.stats.get(e);if(void 0===r)return!0;const s=await t.lstat(e);return null!==r&&(null!==s&&A(r,s))}(t,n,i[D])&&await async function(t,e,i){const r=await t.lstat(e),s=await t.read(e),n=await R.from(s);i.map.set(e,n),i.stats.set(e,r)}(t,n,i[D]);const e=i[D].map.get(n);if(a=await r(e),e._dirty){const r=await e.toObject();await t.write(n,r),i[D].stats.set(n,await t.lstat(n)),e._dirty=!1}}),a}}function M(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return e>-1&&(t=t.slice(e+1)),t}function T(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return-1===e?".":0===e?"/":t.slice(0,e)}function C(t){const e=new Map,i=function(t){if(!e.has(t)){const r={type:"tree",fullpath:t,basename:M(t),metadata:{},children:[]};e.set(t,r),r.parent=i(T(t)),r.parent&&r.parent!==r&&r.parent.children.push(r)}return e.get(t)},r=function(t,r){if(!e.has(t)){const s={type:"blob",fullpath:t,basename:M(t),metadata:r,parent:i(T(t)),children:[]};s.parent&&s.parent.children.push(s),e.set(t,s)}return e.get(t)};i(".");for(const e of t)r(e.path,e);return e}class B{constructor({fs:t,gitdir:e,cache:i}){this.treePromise=U.acquire({fs:t,gitdir:e,cache:i},(async function(t){return C(t.entries)}));const r=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return r.type(this)}async mode(){return r.mode(this)}async stat(){return r.stat(this)}async content(){return r.content(this)}async oid(){return r.oid(this)}}}async readdir(t){const e=t._fullpath,i=(await this.treePromise).get(e);if(!i)return null;if("blob"===i.type)return null;if("tree"!==i.type)throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const r=i.children.map(t=>t.fullpath);return r.sort(x),r}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const e=(await this.treePromise).get(t._fullpath);if(!e)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const i="tree"===e.type?{}:P(e.metadata);t._type="tree"===e.type?"tree":function(t){switch(t){case 16384:return"tree";case 33188:case 33261:case 40960:return"blob";case 57344:return"commit"}throw new _("Unexpected GitTree entry mode: "+t.toString(8))}(i.mode),t._mode=i.mode,"tree"===e.type?t._stat=void 0:t._stat=i}return t._stat}async content(t){}async oid(t){if(!1===t._oid){const e=(await this.treePromise).get(t._fullpath);t._oid=e.metadata.oid}return t._oid}}const F=Symbol("GitWalkSymbol");function z(){const t=Object.create(null);return Object.defineProperty(t,F,{value:function({fs:t,gitdir:e,cache:i}){return new B({fs:t,gitdir:e,cache:i})}}),Object.freeze(t),t}class H extends b{constructor(t){super(`Could not find ${t}.`),this.code=this.name=H.code,this.data={what:t}}}H.code="NotFoundError";class G extends b{constructor(t,e,i,r){super(`Object ${t} ${r?"at "+r:""}was anticipated to be a ${i} but it is a ${e}.`),this.code=this.name=G.code,this.data={oid:t,actual:e,expected:i,filepath:r}}}G.code="ObjectTypeError";class W extends b{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=W.code,this.data={value:t}}}W.code="InvalidOidError";class q extends b{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:\n[remote "${t}"]\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n`),this.code=this.name=q.code,this.data={remote:t}}}q.code="NoRefspecError";class L{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split("\n").map(t=>{if(/^\s*#/.test(t))return{line:t,comment:!0};const i=t.indexOf(" ");if(t.startsWith("^")){const i=t.slice(1);return this.refs.set(e+"^{}",i),{line:t,ref:e,peeled:i}}{const r=t.slice(0,i);return e=t.slice(i+1),this.refs.set(e,r),{line:t,ref:e,oid:r}}})}return this}static from(t){return new L(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join("\n")+"\n"}}class K{constructor({remotePath:t,localPath:e,force:i,matchPrefix:r}){Object.assign(this,{remotePath:t,localPath:e,force:i,matchPrefix:r})}static from(t){const[e,i,r,s,n]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),a="+"===e,o="*"===r;if(o!==("*"===n))throw new _("Invalid refspec");return new K({remotePath:i,localPath:s,force:a,matchPrefix:o})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class V{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const i of t)e.push(K.from(i));return new V(e)}add(t){const e=K.from(t);this.rules.push(e)}translate(t){const e=[];for(const i of this.rules)for(const r of t){const t=i.translate(r);t&&e.push([r,t])}return e}translateOne(t){let e=null;for(const i of this.rules){const r=i.translate(t);r&&(e=r)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function Y(t,e){const i=t.replace(/\^\{\}$/,""),r=e.replace(/\^\{\}$/,""),s=-(i<r)||+(i>r);return 0===s?t.endsWith("^{}")?1:-1:s}function Z(t){return t.replace(/\/\.\//g,"/").replace(/\/{2,}/g,"/").replace(/^\/\.$/,"/").replace(/^\.\/$/,".").replace(/^\.\//,"").replace(/\/\.$/,"").replace(/(.+)\/$/,"$1").replace(/^$/,".")}function J(...t){return Z(t.map(Z).join("/"))}const X=t=>{if("true"===(t=t.trim().toLowerCase())||"yes"===t||"on"===t)return!0;if("false"===t||"no"===t||"off"===t)return!1;throw Error("Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got "+t)},Q={core:{filemode:X,bare:X,logallrefupdates:X,symlinks:X,ignorecase:X,bigFileThreshold:t=>{t=t.toLowerCase();let e=parseInt(t);return t.endsWith("k")&&(e*=1024),t.endsWith("m")&&(e*=1048576),t.endsWith("g")&&(e*=1073741824),e}}},tt=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,et=/^[A-Za-z0-9-.]+$/,it=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,rt=/^[A-Za-z][A-Za-z-]*$/,st=/^(.*?)( *[#;].*)$/,nt=t=>{const e=st.exec(t);if(null==e)return t;const[i,r]=e.slice(1);return at(i)&&at(r)?`${i}${r}`:i},at=t=>(t.match(/(?:^|[^\\])"/g)||[]).length%2!=0,ot=t=>t.split("").reduce((t,e,i,r)=>{const s='"'===e&&"\\"!==r[i-1],n="\\"===e&&'"'===r[i+1];return s||n?t:t+e},""),ct=t=>null!=t?t.toLowerCase():null,dt=(t,e,i)=>[ct(t),e,ct(i)].filter(t=>null!=t).join("."),lt=t=>{const e=t.split("."),i=e.shift(),r=e.pop(),s=e.length?e.join("."):void 0;return{section:i,subsection:s,name:r,path:dt(i,s,r),sectionPath:dt(i,s,null)}};class ht{constructor(t){let e=null,i=null;this.parsedConfig=t.split("\n").map(t=>{let r=null,s=null;const n=t.trim(),a=(t=>{const e=tt.exec(t);if(null!=e){const[t,i]=e.slice(1);return[t,i]}return null})(n),o=null!=a;if(o)[e,i]=a;else{const t=(t=>{const e=it.exec(t);if(null!=e){const[t,i="true"]=e.slice(1),r=nt(i);return[t,ot(r)]}return null})(n);null!=t&&([r,s]=t)}const c=dt(e,i,r);return{line:t,isSection:o,section:e,subsection:i,name:r,value:s,path:c}})}static from(t){return new ht(t)}async get(t,e=!1){const i=lt(t).path,r=this.parsedConfig.filter(t=>t.path===i).map(({section:t,name:e,value:i})=>{const r=Q[t]&&Q[t][e];return r?r(i):i});return e?r:r.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.section===t&&e.isSection).map(t=>t.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(i=>!(i.section===t&&i.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,i=!1){const{section:r,subsection:s,name:n,path:a,sectionPath:o}=lt(t),c=(d=this.parsedConfig,l=t=>t.path===a,d.reduce((t,e,i)=>l(e)?i:t,-1));var d,l;if(null==e)-1!==c&&this.parsedConfig.splice(c,1);else if(-1!==c){const t=this.parsedConfig[c],r=Object.assign({},t,{name:n,value:e,modified:!0});i?this.parsedConfig.splice(c+1,0,r):this.parsedConfig[c]=r}else{const t=this.parsedConfig.findIndex(t=>t.path===o),i={section:r,subsection:s,name:n,value:e,modified:!0,path:a};if(et.test(r)&&rt.test(n))if(t>=0)this.parsedConfig.splice(t+1,0,i);else{const t={section:r,subsection:s,modified:!0,path:o};this.parsedConfig.push(t,i)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:i,name:r,value:s,modified:n=!1})=>n?null!=r&&null!=s?"string"==typeof s&&/[#;]/.test(s)?`\t${r} = "${s}"`:`\t${r} = ${s}`:null!=i?`[${e} "${i}"]`:`[${e}]`:t).join("\n")}}class ft{static async get({fs:t,gitdir:e}){const i=await t.read(e+"/config",{encoding:"utf8"});return ht.from(i)}static async save({fs:t,gitdir:e,config:i}){await t.write(e+"/config",i.toString(),{encoding:"utf8"})}}const ut=t=>[""+t,"refs/"+t,"refs/tags/"+t,"refs/heads/"+t,"refs/remotes/"+t,`refs/remotes/${t}/HEAD`],pt=["config","description","index","shallow","commondir"];class mt{static async updateRemoteRefs({fs:t,gitdir:e,remote:i,refs:r,symrefs:s,tags:n,refspecs:a,prune:o=!1,pruneTags:c=!1}){for(const t of r.values())if(!t.match(/[0-9a-f]{40}/))throw new W(t);const d=await ft.get({fs:t,gitdir:e});if(!a){if(0===(a=await d.getall(`remote.${i}.fetch`)).length)throw new q(i);a.unshift(`+HEAD:refs/remotes/${i}/HEAD`)}const l=V.from(a),h=new Map;if(c){const i=await mt.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await mt.deleteRefs({fs:t,gitdir:e,refs:i.map(t=>"refs/tags/"+t)})}if(n)for(const i of r.keys())if(i.startsWith("refs/tags")&&!i.endsWith("^{}")&&!await mt.exists({fs:t,gitdir:e,ref:i})){const t=r.get(i);h.set(i,t)}const f=l.translate([...r.keys()]);for(const[t,e]of f){const i=r.get(t);h.set(e,i)}const u=l.translate([...s.keys()]);for(const[t,e]of u){const i=s.get(t),r=l.translateOne(i);r&&h.set(e,"ref: "+r)}const p=[];if(o){for(const i of l.localNamespaces()){const r=(await mt.listRefs({fs:t,gitdir:e,filepath:i})).map(t=>`${i}/${t}`);for(const t of r)h.has(t)||p.push(t)}p.length>0&&await mt.deleteRefs({fs:t,gitdir:e,refs:p})}for(const[i,r]of h)await t.write(J(e,i),r.trim()+"\n","utf8");return{pruned:p}}static async writeRef({fs:t,gitdir:e,ref:i,value:r}){if(!r.match(/[0-9a-f]{40}/))throw new W(r);await t.write(J(e,i),r.trim()+"\n","utf8")}static async writeSymbolicRef({fs:t,gitdir:e,ref:i,value:r}){await t.write(J(e,i),"ref: "+r.trim()+"\n","utf8")}static async deleteRef({fs:t,gitdir:e,ref:i}){return mt.deleteRefs({fs:t,gitdir:e,refs:[i]})}static async deleteRefs({fs:t,gitdir:e,refs:i}){await Promise.all(i.map(i=>t.rm(J(e,i))));let r=await t.read(e+"/packed-refs",{encoding:"utf8"});const s=L.from(r),n=s.refs.size;for(const t of i)s.refs.has(t)&&s.delete(t);s.refs.size<n&&(r=s.toString(),await t.write(e+"/packed-refs",r,{encoding:"utf8"}))}static async resolve({fs:t,gitdir:e,ref:i,depth:r}){if(void 0!==r&&-1===--r)return i;let s;if(i.startsWith("ref: "))return i=i.slice("ref: ".length),mt.resolve({fs:t,gitdir:e,ref:i,depth:r});if(40===i.length&&/[0-9a-f]{40}/.test(i))return i;const n=await mt.packedRefs({fs:t,gitdir:e}),a=ut(i).filter(t=>!pt.includes(t));for(const i of a)if(s=await t.read(`${e}/${i}`,{encoding:"utf8"})||n.get(i),s)return mt.resolve({fs:t,gitdir:e,ref:s.trim(),depth:r});throw new H(i)}static async exists({fs:t,gitdir:e,ref:i}){try{return await mt.expand({fs:t,gitdir:e,ref:i}),!0}catch(t){return!1}}static async expand({fs:t,gitdir:e,ref:i}){if(40===i.length&&/[0-9a-f]{40}/.test(i))return i;const r=await mt.packedRefs({fs:t,gitdir:e}),s=ut(i);for(const i of s){if(await t.exists(`${e}/${i}`))return i;if(r.has(i))return i}throw new H(i)}static async expandAgainstMap({ref:t,map:e}){const i=ut(t);for(const t of i)if(await e.has(t))return t;throw new H(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:i,map:r}){if(void 0!==i&&-1===--i)return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice("ref: ".length),mt.resolveAgainstMap({ref:t,fullref:e,depth:i,map:r});if(40===t.length&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const s=ut(t);for(const t of s){const e=r.get(t);if(e)return mt.resolveAgainstMap({ref:e.trim(),fullref:t,depth:i,map:r})}throw new H(t)}static async packedRefs({fs:t,gitdir:e}){const i=await t.read(e+"/packed-refs",{encoding:"utf8"});return L.from(i).refs}static async listRefs({fs:t,gitdir:e,filepath:i}){const r=mt.packedRefs({fs:t,gitdir:e});let s=null;try{s=await t.readdirDeep(`${e}/${i}`),s=s.map(t=>t.replace(`${e}/${i}/`,""))}catch(t){s=[]}for(let t of(await r).keys())t.startsWith(i)&&(t=t.replace(i+"/",""),s.includes(t)||s.push(t));return s.sort(Y),s}static async listBranches({fs:t,gitdir:e,remote:i}){return i?mt.listRefs({fs:t,gitdir:e,filepath:"refs/remotes/"+i}):mt.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await mt.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(t=>!t.endsWith("^{}"))}}function wt(t,e){return x(gt(t),gt(e))}function gt(t){return"040000"===t.mode?t.path+"/":t.path}function yt(t){switch(t){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";case"160000":return"commit"}throw new _("Unexpected GitTree entry mode: "+t)}function bt(t){return!t.oid&&t.sha&&(t.oid=t.sha),t.mode=function(t){if("number"==typeof t&&(t=t.toString(8)),t.match(/^0?4.*/))return"040000";if(t.match(/^1006.*/))return"100644";if(t.match(/^1007.*/))return"100755";if(t.match(/^120.*/))return"120000";if(t.match(/^160.*/))return"160000";throw new _("Could not understand file mode: "+t)}(t.mode),t.type||(t.type=yt(t.mode)),t}class _t{constructor(e){if(t.isBuffer(e))this._entries=function(t){const e=[];let i=0;for(;i<t.length;){const r=t.indexOf(32,i);if(-1===r)throw new _(`GitTree: Error parsing buffer at byte location ${i}: Could not find the next space character.`);const s=t.indexOf(0,i);if(-1===s)throw new _(`GitTree: Error parsing buffer at byte location ${i}: Could not find the next null character.`);let n=t.slice(i,r).toString("utf8");"40000"===n&&(n="040000");const a=yt(n),o=t.slice(r+1,s).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new v(o);const c=t.slice(s+1,s+21).toString("hex");i=s+21,e.push({mode:n,path:o,oid:c,type:a})}return e}(e);else{if(!Array.isArray(e))throw new _("invalid type passed to GitTree constructor");this._entries=e.map(bt)}this._entries.sort(E)}static from(t){return new _t(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join("\n")}toObject(){const e=[...this._entries];return e.sort(wt),t.concat(e.map(e=>{const i=t.from(e.mode.replace(/^0/,"")),r=t.from(" "),s=t.from(e.path,"utf8"),n=t.from([0]),a=t.from(e.oid,"hex");return t.concat([i,r,s,n,a])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class vt{static wrap({type:e,object:i}){return t.concat([t.from(`${e} ${i.byteLength.toString()}\0`),t.from(i)])}static unwrap(e){const i=e.indexOf(32),r=e.indexOf(0),s=e.slice(0,i).toString("utf8"),n=e.slice(i+1,r).toString("utf8"),a=e.length-(r+1);if(parseInt(n)!==a)throw new _(`Length mismatch: expected ${n} bytes but got ${a} instead.`);return{type:s,object:t.from(e.slice(r+1))}}}function kt(t){let e=0,i=0,r=null;do{r=t.readUInt8(),e|=(127&r)<<i,i+=7}while(128&r);return e}function xt(t,e,i){let r=0,s=0;for(;i--;)1&e&&(r|=t.readUInt8()<<s),e>>=1,s+=8;return r}function Et(t,e){const i=t.readUInt8();if(128&i){const r=xt(t,15&i,4);let s=xt(t,(112&i)>>4,3);return 0===s&&(s=65536),e.slice(r,r+s)}return t.slice(i)}function $t(t){return t[Symbol.asyncIterator]?t[Symbol.asyncIterator]():t[Symbol.iterator]?t[Symbol.iterator]():t.next?t:function(t){let e=[t];return{next:()=>Promise.resolve({done:0===e.length,value:e.pop()}),return:()=>(e=[],{}),[Symbol.asyncIterator](){return this}}}(t)}class St{constructor(t){this.stream=$t(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:e,value:i}=await this.stream.next();return e&&(this._ended=!0),i&&(i=t.from(i)),i}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(e){if(this._ended)return;const i=[this.buffer];for(;this.cursor+e>Pt(i);){const t=await this._next();if(this._ended)break;i.push(t)}this.buffer=t.concat(i)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function Pt(t){return t.reduce((t,e)=>t+e.length,0)}async function It(e){let i=await e.byte();const r=i>>4&7;let s,n,a=15&i;if(128&i){let t=4;do{i=await e.byte(),a|=(127&i)<<t,t+=7}while(128&i)}if(6===r){let r=0;s=0;const a=[];do{i=await e.byte(),s|=(127&i)<<r,r+=7,a.push(i)}while(128&i);n=t.from(a)}if(7===r){n=await e.read(20)}return{type:r,length:a,ofs:s,reference:n}}let jt=!1;async function Ot(t){return null===jt&&(jt=function(){try{if(new DecompressionStream("deflate"))return!0}catch(t){}return!1}()),jt?async function(t){const e=new DecompressionStream("deflate"),i=new Blob([t]).stream().pipeThrough(e);return new Uint8Array(await new Response(i).arrayBuffer())}(t):l.a.inflate(t)}class Rt{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const i=new k(t);if("ff744f63"!==i.slice(4).toString("hex"))return;const r=i.readUInt32BE();if(2!==r)throw new _(`Unable to read version ${r} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2147483648)throw new _("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");i.seek(i.tell()+1020);const s=i.readUInt32BE(),n=[];for(let t=0;t<s;t++){const e=i.slice(20).toString("hex");n[t]=e}i.seek(i.tell()+4*s);const a=new Map;for(let t=0;t<s;t++)a.set(n[t],i.readUInt32BE());const o=i.slice(20).toString("hex");return new Rt({hashes:n,crcs:{},offsets:a,packfileSha:o,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:i}){const r={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},s={},n=t.slice(-20).toString("hex"),a=[],o={},d=new Map;let h=null,f=null;await async function(t,e){const i=new St(t);let r=await i.read(4);if(r=r.toString("utf8"),"PACK"!==r)throw new _(`Invalid PACK header '${r}'`);let s=await i.read(4);if(s=s.readUInt32BE(0),2!==s)throw new _("Invalid packfile version: "+s);let n=await i.read(4);if(n=n.readUInt32BE(0),!(n<1))for(;!i.eof()&&n--;){const t=i.tell(),{type:r,length:s,ofs:a,reference:o}=await It(i),c=new l.a.Inflate;for(;!c.result;){const d=await i.chunk();if(!d)break;if(c.push(d,!1),c.err)throw new _("Pako error: "+c.msg);if(c.result){if(c.result.length!==s)throw new _("Inflated object size is different from that stated in packfile.");await i.undo(),await i.read(d.length-c.strm.avail_in);const l=i.tell();await e({data:c.result,type:r,num:n,offset:t,end:l,reference:o,ofs:a})}}}}([t],async({data:t,type:e,reference:n,offset:a,num:o})=>{null===h&&(h=o);const c=Math.floor(100*(h-o)/h);c!==f&&i&&await i({phase:"Receiving objects",loaded:h-o,total:h}),f=c,(["commit","tree","blob","tag"].includes(e=r[e])||"ofs-delta"===e||"ref-delta"===e)&&(s[a]={type:e,offset:a})});const u=Object.keys(s).map(Number);for(const[e,i]of u.entries()){const r=e+1===u.length?t.byteLength-20:u[e+1],n=s[i],a=c.a.buf(t.slice(i,r))>>>0;n.end=r,n.crc=a}const p=new Rt({pack:Promise.resolve(t),packfileSha:n,crcs:o,hashes:a,offsets:d,getExternalRefDelta:e});f=null;let m=0;const w=[0,0,0,0,0,0,0,0,0,0,0,0];for(let t in s){t=Number(t);const e=Math.floor(100*m/h);e!==f&&i&&await i({phase:"Resolving deltas",loaded:m,total:h}),m++,f=e;const r=s[t];if(!r.oid)try{p.readDepth=0,p.externalReadDepth=0;const{type:e,object:i}=await p.readSlice({start:t});w[p.readDepth]+=1;const s=await j(vt.wrap({type:e,object:i}));r.oid=s,a.push(s),d.set(s,t),o[s]=r.crc}catch(t){continue}}return a.sort(),p}async toBuffer(){const e=[],i=(i,r)=>{e.push(t.from(i,r))};i("ff744f63","hex"),i("00000002","hex");const r=new k(t.alloc(1024));for(let t=0;t<256;t++){let e=0;for(const i of this.hashes)parseInt(i.slice(0,2),16)<=t&&e++;r.writeUInt32BE(e)}e.push(r.buffer);for(const t of this.hashes)i(t,"hex");const s=new k(t.alloc(4*this.hashes.length));for(const t of this.hashes)s.writeUInt32BE(this.crcs[t]);e.push(s.buffer);const n=new k(t.alloc(4*this.hashes.length));for(const t of this.hashes)n.writeUInt32BE(this.offsets.get(t));e.push(n.buffer),i(this.packfileSha,"hex");const a=t.concat(e),o=await j(a),c=t.alloc(20);return c.write(o,"hex"),t.concat([a,c])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new _(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:e}){if(this.offsetCache[e])return Object.assign({},this.offsetCache[e]);this.readDepth++;if(!this.pack)throw new _("Tried to read from a GitPackIndex with no packfile loaded into memory");const i=(await this.pack).slice(e),r=new k(i),s=r.readUInt8(),n=112&s;let a={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"}[n];if(void 0===a)throw new _("Unrecognized type: 0b"+n.toString(2));const o=15&s;let c=o;128&s&&(c=function(t,e){let i=e,r=4,s=null;do{s=t.readUInt8(),i|=(127&s)<<r,r+=7}while(128&s);return i}(r,o));let d=null,l=null;if("ofs_delta"===a){const t=e-function(t){const e=[];let i=0,r=0;do{i=t.readUInt8();const s=127&i;e.push(s),r=128&i}while(r);return e.reduce((t,e)=>t+1<<7|e,-1)}(r);({object:d,type:a}=await this.readSlice({start:t}))}if("ref_delta"===a){const t=r.slice(20).toString("hex");({object:d,type:a}=await this.read({oid:t}))}const h=i.slice(r.tell());if(l=t.from(await Ot(h)),l.byteLength!==c)throw new _(`Packfile told us object would have length ${c} but it had length ${l.byteLength}`);return d&&(l=t.from(function(e,i){const r=new k(e),s=kt(r);if(s!==i.byteLength)throw new _(`applyDelta expected source buffer to be ${s} bytes but the provided buffer was ${i.length} bytes`);const n=kt(r);let a;const o=Et(r,i);if(o.byteLength===n)a=o;else{a=t.alloc(n);const e=new k(a);for(e.copy(o);!r.eof();)e.copy(Et(r,i));const s=e.tell();if(n!==s)throw new _(`applyDelta expected target buffer to be ${n} bytes but the resulting buffer was ${s} bytes`)}return a}(l,d))),this.readDepth>3&&(this.offsetCache[e]={type:a,object:l}),{type:a,format:"content",object:l}}}const At=Symbol("PackfileCache");function Nt({fs:t,cache:e,filename:i,getExternalRefDelta:r,emitter:s,emitterPrefix:n}){e[At]||(e[At]=new Map);let a=e[At].get(i);return a||(a=async function({fs:t,filename:e,getExternalRefDelta:i,emitter:r,emitterPrefix:s}){const n=await t.read(e);return Rt.fromIdx({idx:n,getExternalRefDelta:i})}({fs:t,filename:i,getExternalRefDelta:r,emitter:s,emitterPrefix:n}),e[At].set(i,a)),a}async function Dt({fs:e,cache:i,gitdir:r,oid:s,format:n="content"}){const a=t=>Dt({fs:e,cache:i,gitdir:r,oid:t});let o;if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===s&&(o={format:"wrapped",object:t.from("tree 0\0")}),o||(o=await async function({fs:t,gitdir:e,oid:i}){const r=`objects/${i.slice(0,2)}/${i.slice(2)}`,s=await t.read(`${e}/${r}`);return s?{object:s,format:"deflated",source:r}:null}({fs:e,gitdir:r,oid:s})),o||(o=await async function({fs:t,cache:e,gitdir:i,oid:r,format:s="content",getExternalRefDelta:n}){let a=await t.readdir(J(i,"objects/pack"));a=a.filter(t=>t.endsWith(".idx"));for(const s of a){const a=`${i}/objects/pack/${s}`,o=await Nt({fs:t,cache:e,filename:a,getExternalRefDelta:n});if(o.error)throw new _(o.error);if(o.offsets.has(r)){if(!o.pack){const e=a.replace(/idx$/,"pack");o.pack=t.read(e)}const e=await o.read({oid:r,getExternalRefDelta:n});return e.format="content",e.source="objects/pack/"+s.replace(/idx$/,"pack"),e}}return null}({fs:e,cache:i,gitdir:r,oid:s,getExternalRefDelta:a})),!o)throw new H(s);if("deflated"===n)return o;if("deflated"===o.format&&(o.object=t.from(await Ot(o.object)),o.format="wrapped"),"wrapped"===o.format){if("wrapped"===n&&"wrapped"===o.format)return o;const t=await j(o.object);if(t!==s)throw new _(`SHA check failed! Expected ${s}, computed ${t}`);const{object:e,type:i}=vt.unwrap(o.object);o.type=i,o.object=e,o.format="content"}if("content"===o.format)return"content"===n?o:void 0;throw new _(`invalid format "${o.format}"`)}class Ut extends b{constructor(t,e,i=!0){super(`Failed to create ${t} at ${e} because it already exists.${i?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=Ut.code,this.data={noun:t,where:e,canForce:i}}}Ut.code="AlreadyExistsError";class Mt extends b{constructor(t,e,i){super(`Found multiple ${t} matching "${e}" (${i.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=Mt.code,this.data={nouns:t,short:e,matches:i}}}Mt.code="AmbiguousError";class Tt extends b{constructor(t){super("Your local changes to the following files would be overwritten by checkout: "+t.join(", ")),this.code=this.name=Tt.code,this.data={filepaths:t}}}Tt.code="CheckoutConflictError";class Ct extends b{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Ct.code,this.data={ref:t,oid:e}}}Ct.code="CommitNotFetchedError";class Bt extends b{constructor(){super("Empty response from git server."),this.code=this.name=Bt.code,this.data={}}}Bt.code="EmptyServerResponseError";class Ft extends b{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=Ft.code,this.data={}}}Ft.code="FastForwardError";class zt extends b{constructor(t,e){super("One or more branches were not updated: "+t),this.code=this.name=zt.code,this.data={prettyDetails:t,result:e}}}zt.code="GitPushError";class Ht extends b{constructor(t,e,i){super(`HTTP Error: ${t} ${e}`),this.code=this.name=Ht.code,this.data={statusCode:t,statusMessage:e,response:i}}}Ht.code="HttpError";class Gt extends b{constructor(t){let e="invalid filepath";"leading-slash"===t||"trailing-slash"===t?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':"directory"===t&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Gt.code,this.data={reason:t}}}Gt.code="InvalidFilepathError";class Wt extends b{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=Wt.code,this.data={ref:t,suggestion:e}}}Wt.code="InvalidRefNameError";class qt extends b{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=qt.code,this.data={depth:t}}}qt.code="MaxDepthError";class Lt extends b{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Lt.code,this.data={}}}Lt.code="MergeNotSupportedError";class Kt extends b{constructor(t){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Kt.code,this.data={filepaths:t}}}Kt.code="MergeConflictError";class Vt extends b{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=Vt.code,this.data={role:t}}}Vt.code="MissingNameError";class Yt extends b{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=Yt.code,this.data={parameter:t}}}Yt.code="MissingParameterError";class Zt extends b{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=Zt.code,this.data={errors:t},this.errors=t}}Zt.code="MultipleGitError";class Jt extends b{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=Jt.code,this.data={expected:t,actual:e}}}Jt.code="ParseError";class Xt extends b{constructor(t){let e="";"not-fast-forward"===t?e=" because it was not a simple fast-forward":"tag-exists"===t&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=Xt.code,this.data={reason:t}}}Xt.code="PushRejectedError";class Qt extends b{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Qt.code,this.data={capability:t,parameter:e}}}Qt.code="RemoteCapabilityError";class te extends b{constructor(t,e){super('Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: '+t),this.code=this.name=te.code,this.data={preview:t,response:e}}}te.code="SmartHttpError";class ee extends b{constructor(t,e,i){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=ee.code,this.data={url:t,transport:e,suggestion:i}}}ee.code="UnknownTransportError";class ie extends b{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=ie.code,this.data={url:t}}}ie.code="UrlParseError";class re extends b{constructor(){super("The operation was canceled."),this.code=this.name=re.code,this.data={}}}re.code="UserCanceledError";var se=Object.freeze({__proto__:null,AlreadyExistsError:Ut,AmbiguousError:Mt,CheckoutConflictError:Tt,CommitNotFetchedError:Ct,EmptyServerResponseError:Bt,FastForwardError:Ft,GitPushError:zt,HttpError:Ht,InternalError:_,InvalidFilepathError:Gt,InvalidOidError:W,InvalidRefNameError:Wt,MaxDepthError:qt,MergeNotSupportedError:Lt,MergeConflictError:Kt,MissingNameError:Vt,MissingParameterError:Yt,MultipleGitError:Zt,NoRefspecError:q,NotFoundError:H,ObjectTypeError:G,ParseError:Jt,PushRejectedError:Xt,RemoteCapabilityError:Qt,SmartHttpError:te,UnknownTransportError:ee,UnsafeFilepathError:v,UrlParseError:ie,UserCanceledError:re});function ne({name:t,email:e,timestamp:i,timezoneOffset:r}){return`${t} <${e}> ${i} ${r=function(t){const e=function(t){return Math.sign(t)||(Object.is(t,-0)?-1:1)}((i=t,0===i?i:-i));var i;t=Math.abs(t);const r=Math.floor(t/60);t-=60*r;let s=String(r),n=String(t);s.length<2&&(s="0"+s);n.length<2&&(n="0"+n);return(-1===e?"-":"+")+s+n}(r)}`}function ae(t){return t=(t=(t=t.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function oe(t){const[,e,i,r,s]=t.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:e,email:i,timestamp:Number(r),timezoneOffset:ce(s)}}function ce(t){let[,e,i,r]=t.match(/(\+|-)(\d\d)(\d\d)/);return r=("+"===e?1:-1)*(60*Number(i)+Number(r)),0===(s=r)?s:-s;var s}class de{constructor(e){if("string"==typeof e)this._tag=e;else if(t.isBuffer(e))this._tag=e.toString("utf8");else{if("object"!=typeof e)throw new _("invalid type passed to GitAnnotatedTag constructor");this._tag=de.render(e)}}static from(t){return new de(t)}static render(t){return`object ${t.object}\ntype ${t.type}\ntag ${t.tag}\ntagger ${ne(t.tagger)}\n\n${t.message}\n${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf("\n\n"))}message(){const t=this.withoutSignature();return t.slice(t.indexOf("\n\n")+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split("\n"),e=[];for(const i of t)" "===i[0]?e[e.length-1]+="\n"+i.slice(1):e.push(i);const i={};for(const t of e){const e=t.slice(0,t.indexOf(" ")),r=t.slice(t.indexOf(" ")+1);Array.isArray(i[e])?i[e].push(r):i[e]=r}return i.tagger&&(i.tagger=oe(i.tagger)),i.committer&&(i.committer=oe(i.committer)),i}withoutSignature(){const t=ae(this._tag);return-1===t.indexOf("\n-----BEGIN PGP SIGNATURE-----")?t:t.slice(0,t.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"))}gpgsig(){if(-1===this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----"))return;return ae(this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length))}payload(){return this.withoutSignature()+"\n"}toObject(){return t.from(this._tag,"utf8")}static async sign(t,e,i){const r=t.payload();let{signature:s}=await e({payload:r,secretKey:i});s=ae(s);const n=r+s;return de.from(n)}}function le(t){return t.trim().split("\n").map(t=>" "+t).join("\n")+"\n"}class he{constructor(e){if("string"==typeof e)this._commit=e;else if(t.isBuffer(e))this._commit=e.toString("utf8");else{if("object"!=typeof e)throw new _("invalid type passed to GitCommit constructor");this._commit=he.render(e)}}static fromPayloadSignature({payload:t,signature:e}){const i=he.justHeaders(t),r=he.justMessage(t),s=ae(i+"\ngpgsig"+le(e)+"\n"+r);return new he(s)}static from(t){return new he(t)}toObject(){return t.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return he.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return ae(t.slice(t.indexOf("\n\n")+2))}static justHeaders(t){return t.slice(0,t.indexOf("\n\n"))}parseHeaders(){const t=he.justHeaders(this._commit).split("\n"),e=[];for(const i of t)" "===i[0]?e[e.length-1]+="\n"+i.slice(1):e.push(i);const i={parent:[]};for(const t of e){const e=t.slice(0,t.indexOf(" ")),r=t.slice(t.indexOf(" ")+1);Array.isArray(i[e])?i[e].push(r):i[e]=r}return i.author&&(i.author=oe(i.author)),i.committer&&(i.committer=oe(i.committer)),i}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}\n`:e+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",t.parent){if(void 0===t.parent.length)throw new _("commit 'parent' property should be an array");for(const i of t.parent)e+=`parent ${i}\n`}e+=`author ${ne(t.author)}\n`;return e+=`committer ${ne(t.committer||t.author)}\n`,t.gpgsig&&(e+="gpgsig"+le(t.gpgsig)),e}static render(t){return he.renderHeaders(t)+"\n"+ae(t.message)}render(){return this._commit}withoutSignature(){const t=ae(this._commit);if(-1===t.indexOf("\ngpgsig"))return t;return ae(t.slice(0,t.indexOf("\ngpgsig"))+"\n"+t.slice(t.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return t.split("\n").map(t=>t.replace(/^ /,"")).join("\n")}static async sign(t,e,i){const r=t.withoutSignature(),s=he.justMessage(t._commit);let{signature:n}=await e({payload:r,secretKey:i});n=ae(n);const a=he.justHeaders(t._commit)+"\ngpgsig"+le(n)+"\n"+s;return he.from(a)}}async function fe({fs:t,cache:e,gitdir:i,oid:r}){if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===r)return{tree:_t.from([]),oid:r};const{type:s,object:n}=await Dt({fs:t,cache:e,gitdir:i,oid:r});if("tag"===s)return fe({fs:t,cache:e,gitdir:i,oid:r=de.from(n).parse().object});if("commit"===s)return fe({fs:t,cache:e,gitdir:i,oid:r=he.from(n).parse().tree});if("tree"!==s)throw new G(r,s,"tree");return{tree:_t.from(n),oid:r}}class ue{constructor({fs:t,gitdir:e,ref:i,cache:r}){this.fs=t,this.cache=r,this.gitdir=e,this.mapPromise=(async()=>{const r=new Map;let s;try{s=await mt.resolve({fs:t,gitdir:e,ref:i})}catch(t){t instanceof H&&(s="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const n=await fe({fs:t,cache:this.cache,gitdir:e,oid:s});return n.type="tree",n.mode="40000",r.set(".",n),r})();const s=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,cache:r,gitdir:s}=this,n=await this.mapPromise,a=n.get(e);if(!a)throw new Error("No obj for "+e);const o=a.oid;if(!o)throw new Error("No oid for obj "+JSON.stringify(a));if("tree"!==a.type)return null;const{type:c,object:d}=await Dt({fs:i,cache:r,gitdir:s,oid:o});if(c!==a.type)throw new G(o,c,a.type);const l=_t.from(d);for(const t of l)n.set(J(e,t.path),t);return l.entries().map(t=>J(e,t.path))}async type(t){if(!1===t._type){const e=await this.mapPromise,{type:i}=e.get(t._fullpath);t._type=i}return t._type}async mode(t){if(!1===t._mode){const e=await this.mapPromise,{mode:i}=e.get(t._fullpath);t._mode=$(parseInt(i,8))}return t._mode}async stat(t){}async content(t){if(!1===t._content){const e=await this.mapPromise,{fs:i,cache:r,gitdir:s}=this,n=e.get(t._fullpath).oid,{type:a,object:o}=await Dt({fs:i,cache:r,gitdir:s,oid:n});t._content="blob"!==a?void 0:new Uint8Array(o)}return t._content}async oid(t){if(!1===t._oid){const e=(await this.mapPromise).get(t._fullpath);t._oid=e.oid}return t._oid}}function pe({ref:t="HEAD"}){const e=Object.create(null);return Object.defineProperty(e,F,{value:function({fs:e,gitdir:i,cache:r}){return new ue({fs:e,gitdir:i,ref:t,cache:r})}}),Object.freeze(e),e}class me{constructor({fs:t,dir:e,gitdir:i,cache:r}){this.fs=t,this.cache=r,this.dir=e,this.gitdir=i;const s=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,dir:r}=this,s=await i.readdir(J(r,e));return null===s?null:s.map(t=>J(e,t))}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const{fs:e,dir:i}=this;let r=await e.lstat(`${i}/${t._fullpath}`);if(!r)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let s=r.isDirectory()?"tree":"blob";"blob"!==s||r.isFile()||r.isSymbolicLink()||(s="special"),t._type=s,r=P(r),t._mode=r.mode,-1===r.size&&t._actualSize&&(r.size=t._actualSize),t._stat=r}return t._stat}async content(t){if(!1===t._content){const{fs:e,dir:i}=this;if("tree"===await t.type())t._content=void 0;else{const r=await e.read(`${i}/${t._fullpath}`);t._actualSize=r.length,t._stat&&-1===t._stat.size&&(t._stat.size=t._actualSize),t._content=new Uint8Array(r)}}return t._content}async oid(t){if(!1===t._oid){const{fs:e,gitdir:i,cache:r}=this;let s;await U.acquire({fs:e,gitdir:i,cache:r},(async function(e){const i=e.entriesMap.get(t._fullpath),r=await t.stat();if(!i||A(r,i)){void 0===await t.content()?s=void 0:(s=await j(vt.wrap({type:"blob",object:await t.content()})),i&&s===i.oid&&r.mode===i.mode&&A(r,i)&&e.insert({filepath:t._fullpath,stats:r,oid:s}))}else s=i.oid})),t._oid=s}return t._oid}}function we(){const t=Object.create(null);return Object.defineProperty(t,F,{value:function({fs:t,dir:e,gitdir:i,cache:r}){return new me({fs:t,dir:e,gitdir:i,cache:r})}}),Object.freeze(t),t}class ge{static async isIgnored({fs:t,dir:e,gitdir:i=J(e,".git"),filepath:r}){if(".git"===M(r))return!0;if("."===r)return!1;let s="";const n=J(i,"info","exclude");await t.exists(n)&&(s=await t.read(n,"utf8"));const a=[{gitignore:J(e,".gitignore"),filepath:r}],o=r.split("/").filter(Boolean);for(let t=1;t<o.length;t++){const i=o.slice(0,t).join("/"),r=o.slice(t).join("/");a.push({gitignore:J(e,i,".gitignore"),filepath:r})}let c=!1;for(const e of a){let i;try{i=await t.read(e.gitignore,"utf8")}catch(t){if("NOENT"===t.code)continue}const r=f()().add(s);r.add(i);const n=T(e.filepath);if("."!==n&&r.ignores(n))return!0;c=c?!r.test(e.filepath).unignored:r.test(e.filepath).ignored}return c}}async function ye(t,e){const i=await t.readdir(e);null==i?await t.rm(e):i.length?await Promise.all(i.map(i=>{const r=J(e,i);return t.lstat(r).then(e=>{if(e)return e.isDirectory()?ye(t,r):t.rm(r)})})).then(()=>t.rmdir(e)):await t.rmdir(e)}class be{constructor(t){if(void 0!==t._original_unwrapped_fs)return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?(this._readFile=t.promises.readFile.bind(t.promises),this._writeFile=t.promises.writeFile.bind(t.promises),this._mkdir=t.promises.mkdir.bind(t.promises),t.promises.rm?this._rm=t.promises.rm.bind(t.promises):t.promises.rmdir.length>1?this._rm=t.promises.rmdir.bind(t.promises):this._rm=ye.bind(null,this),this._rmdir=t.promises.rmdir.bind(t.promises),this._unlink=t.promises.unlink.bind(t.promises),this._stat=t.promises.stat.bind(t.promises),this._lstat=t.promises.lstat.bind(t.promises),this._readdir=t.promises.readdir.bind(t.promises),this._readlink=t.promises.readlink.bind(t.promises),this._symlink=t.promises.symlink.bind(t.promises)):(this._readFile=p()(t.readFile.bind(t)),this._writeFile=p()(t.writeFile.bind(t)),this._mkdir=p()(t.mkdir.bind(t)),t.rm?this._rm=p()(t.rm.bind(t)):t.rmdir.length>2?this._rm=p()(t.rmdir.bind(t)):this._rm=ye.bind(null,this),this._rmdir=p()(t.rmdir.bind(t)),this._unlink=p()(t.unlink.bind(t)),this._stat=p()(t.stat.bind(t)),this._lstat=p()(t.lstat.bind(t)),this._readdir=p()(t.readdir.bind(t)),this._readlink=p()(t.readlink.bind(t)),this._symlink=p()(t.symlink.bind(t))),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(t){if("ENOENT"===t.code||"ENOTDIR"===t.code)return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',t),t}}async read(e,i={}){try{let r=await this._readFile(e,i);return"string"!=typeof r&&(r=t.from(r)),r}catch(t){return null}}async write(t,e,i={}){try{return void await this._writeFile(t,e,i)}catch(r){await this.mkdir(T(t)),await this._writeFile(t,e,i)}}async mkdir(t,e=!1){try{return void await this._mkdir(t)}catch(i){if(null===i)return;if("EEXIST"===i.code)return;if(e)throw i;if("ENOENT"===i.code){const e=T(t);if("."===e||"/"===e||e===t)throw i;await this.mkdir(e),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(t){if("ENOENT"!==t.code)throw t}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(t){if("ENOENT"!==t.code)throw t}}async readdir(t){try{const e=await this._readdir(t);return e.sort(x),e}catch(t){return"ENOTDIR"===t.code?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async e=>{const i=t+"/"+e;return(await this._stat(i)).isDirectory()?this.readdirDeep(i):i}))).reduce((t,e)=>t.concat(e),[])}async lstat(t){try{return await this._lstat(t)}catch(t){if("ENOENT"===t.code)return null;throw t}}async readlink(e,i={encoding:"buffer"}){try{const r=await this._readlink(e,i);return t.isBuffer(r)?r:t.from(r)}catch(t){if("ENOENT"===t.code)return null;throw t}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}let _e=null;async function ve(t){return null===_e&&(_e=function(){try{const t=new CompressionStream("deflate");if(new Blob([]).stream(),t)return!0}catch(t){}return!1}()),_e?async function(t){const e=new CompressionStream("deflate"),i=new Blob([t]).stream().pipeThrough(e);return new Uint8Array(await new Response(i).arrayBuffer())}(t):l.a.deflate(t)}async function ke({fs:e,gitdir:i,type:r,object:s,format:n="content",oid:a,dryRun:o=!1}){return"deflated"!==n&&("wrapped"!==n&&(s=vt.wrap({type:r,object:s})),a=await j(s),s=t.from(await ve(s))),o||await async function({fs:t,gitdir:e,object:i,format:r,oid:s}){if("deflated"!==r)throw new _("GitObjectStoreLoose expects objects to write to be in deflated format");const n=`${e}/${`objects/${s.slice(0,2)}/${s.slice(2)}`}`;await t.exists(n)||await t.write(n,i)}({fs:e,gitdir:i,object:s,format:"deflated",oid:a}),a}function xe(t,e){if(void 0===e)throw new Yt(t)}async function Ee({fs:t,dir:e,gitdir:i=J(e,".git"),filepath:r,cache:s={},force:n=!1}){try{xe("fs",t),xe("dir",e),xe("gitdir",i),xe("filepath",r);const a=new be(t);await U.acquire({fs:a,gitdir:i,cache:s},async t=>async function t({dir:e,gitdir:i,fs:r,filepath:s,index:n,force:a}){const o=(s=Array.isArray(s)?s:[s]).map(async s=>{if(!a){if(await ge.isIgnored({fs:r,dir:e,gitdir:i,filepath:s}))return}const o=await r.lstat(J(e,s));if(!o)throw new H(s);if(o.isDirectory()){const o=(await r.readdir(J(e,s))).map(o=>t({dir:e,gitdir:i,fs:r,filepath:[J(s,o)],index:n,force:a}));await Promise.all(o)}else{const t=o.isSymbolicLink()?await r.readlink(J(e,s)):await r.read(J(e,s));if(null===t)throw new H(s);const a=await ke({fs:r,gitdir:i,type:"blob",object:t});n.insert({filepath:s,stats:o,oid:a})}}),c=await Promise.allSettled(o),d=c.filter(t=>"rejected"===t.status).map(t=>t.reason);if(d.length>1)throw new Zt(d);if(1===d.length)throw d[0];return c.filter(t=>"fulfilled"===t.status&&t.value).map(t=>t.value)}({dir:e,gitdir:i,fs:a,filepath:r,index:t,force:n}))}catch(t){throw t.caller="git.add",t}}async function $e({fs:t,cache:e,onSign:i,gitdir:r,message:s,author:n,committer:a,signingKey:o,dryRun:c=!1,noUpdateBranch:d=!1,ref:l,parent:h,tree:f}){return l||(l=await mt.resolve({fs:t,gitdir:r,ref:"HEAD",depth:2})),U.acquire({fs:t,gitdir:r,cache:e},(async function(e){const u=C(e.entries).get(".");if(f||(f=await async function t({fs:e,gitdir:i,inode:r,dryRun:s}){const n=r.children;for(const r of n)"tree"===r.type&&(r.metadata.mode="040000",r.metadata.oid=await t({fs:e,gitdir:i,inode:r,dryRun:s}));const a=n.map(t=>({mode:t.metadata.mode,path:t.basename,oid:t.metadata.oid,type:t.type})),o=_t.from(a);return await ke({fs:e,gitdir:i,type:"tree",object:o.toObject(),dryRun:s})}({fs:t,gitdir:r,inode:u,dryRun:c})),h)h=await Promise.all(h.map(e=>mt.resolve({fs:t,gitdir:r,ref:e})));else try{h=[await mt.resolve({fs:t,gitdir:r,ref:l})]}catch(t){h=[]}let p=he.from({tree:f,parent:h,author:n,committer:a,message:s});o&&(p=await he.sign(p,i,o));const m=await ke({fs:t,gitdir:r,type:"commit",object:p.toObject(),dryRun:c});return d||c||await mt.writeRef({fs:t,gitdir:r,ref:l,value:m}),m}))}async function Se({fs:t,cache:e,gitdir:i,oid:r,filepath:s}){if(s.startsWith("/"))throw new Gt("leading-slash");if(s.endsWith("/"))throw new Gt("trailing-slash");const n=r,a=await fe({fs:t,cache:e,gitdir:i,oid:r}),o=a.tree;if(""===s)r=a.oid;else{const a=s.split("/");r=await async function t({fs:e,cache:i,gitdir:r,tree:s,pathArray:n,oid:a,filepath:o}){const c=n.shift();for(const d of s)if(d.path===c){if(0===n.length)return d.oid;{const{type:c,object:l}=await Dt({fs:e,cache:i,gitdir:r,oid:d.oid});if("tree"!==c)throw new G(a,c,"blob",o);return s=_t.from(l),t({fs:e,cache:i,gitdir:r,tree:s,pathArray:n,oid:a,filepath:o})}}throw new H(`file or directory found at "${a}:${o}"`)}({fs:t,cache:e,gitdir:i,tree:o,pathArray:a,oid:n,filepath:s})}return r}async function Pe({fs:t,gitdir:e,path:i}){return(await ft.get({fs:t,gitdir:e})).get(i)}async function Ie({fs:t,gitdir:e,author:i={}}){let{name:r,email:s,timestamp:n,timezoneOffset:a}=i;if(r=r||await Pe({fs:t,gitdir:e,path:"user.name"}),s=s||await Pe({fs:t,gitdir:e,path:"user.email"})||"",void 0!==r)return n=null!=n?n:Math.floor(Date.now()/1e3),a=null!=a?a:new Date(1e3*n).getTimezoneOffset(),{name:r,email:s,timestamp:n,timezoneOffset:a}}async function je({fs:t,gitdir:e,author:i,committer:r}){return r=Object.assign({},r||i),i&&(r.timestamp=r.timestamp||i.timestamp,r.timezoneOffset=r.timezoneOffset||i.timezoneOffset),r=await Ie({fs:t,gitdir:e,author:r})}async function Oe({fs:t,gitdir:e,remote:i,url:r,force:s}){if(i!==w.a.clean(i))throw new Wt(i,w.a.clean(i));const n=await ft.get({fs:t,gitdir:e});if(!s){if((await n.getSubsections("remote")).includes(i)&&r!==await n.get(`remote.${i}.url`))throw new Ut("remote",i)}await n.set(`remote.${i}.url`,r),await n.set(`remote.${i}.fetch`,`+refs/heads/*:refs/remotes/${i}/*`),await ft.save({fs:t,gitdir:e,config:n})}async function Re({fs:t,dir:e,gitdir:i=J(e,".git"),remote:r,url:s,force:n=!1}){try{return xe("fs",t),xe("gitdir",i),xe("remote",r),xe("url",s),await Oe({fs:new be(t),gitdir:i,remote:r,url:s,force:n})}catch(t){throw t.caller="git.addRemote",t}}async function Ae({fs:t,dir:e,gitdir:i=J(e,".git"),ref:r,checkout:s=!1}){try{return xe("fs",t),xe("gitdir",i),xe("ref",r),await async function({fs:t,gitdir:e,ref:i,checkout:r=!1}){if(i!==w.a.clean(i))throw new Wt(i,w.a.clean(i));const s="refs/heads/"+i;if(await mt.exists({fs:t,gitdir:e,ref:s}))throw new Ut("branch",i,!1);let n;try{n=await mt.resolve({fs:t,gitdir:e,ref:"HEAD"})}catch(t){}n&&await mt.writeRef({fs:t,gitdir:e,ref:s,value:n}),r&&await mt.writeSymbolicRef({fs:t,gitdir:e,ref:"HEAD",value:s})}({fs:new be(t),gitdir:i,ref:r,checkout:s})}catch(t){throw t.caller="git.branch",t}}const Ne=void 0===Array.prototype.flat?t=>t.reduce((t,e)=>t.concat(e),[]):t=>t.flat();class De{constructor(){this.value=null}consider(t){null!=t&&(null===this.value||t<this.value)&&(this.value=t)}reset(){this.value=null}}function*Ue(t){const e=new De;let i;const r=[],s=t.length;for(let i=0;i<s;i++)r[i]=t[i].next().value,void 0!==r[i]&&e.consider(r[i]);if(null!==e.value)for(;;){const n=[];i=e.value,e.reset();for(let a=0;a<s;a++)void 0!==r[a]&&r[a]===i?(n[a]=r[a],r[a]=t[a].next().value):n[a]=null,void 0!==r[a]&&e.consider(r[a]);if(yield n,null===e.value)return}}async function Me({fs:t,cache:e,dir:i,gitdir:r,trees:s,map:n=(async(t,e)=>e),reduce:a=(async(t,e)=>{const i=Ne(e);return void 0!==t&&i.unshift(t),i}),iterate:o=((t,e)=>Promise.all([...e].map(t)))}){const c=s.map(s=>s[F]({fs:t,dir:i,gitdir:r,cache:e})),d=new Array(c.length).fill("."),l=function(t,e){const i=e-t;return Array.from({length:i},(e,i)=>t+i)}(0,c.length),h=async t=>{const{entries:e,children:i}=await(async t=>{l.map(e=>{t[e]=t[e]&&new c[e].ConstructEntry(t[e])});const e=(await Promise.all(l.map(e=>t[e]?c[e].readdir(t[e]):[]))).map(t=>null===t?[]:t).map(t=>t[Symbol.iterator]());return{entries:t,children:Ue(e)}})(t),r=e.find(t=>t&&t._fullpath)._fullpath,s=await n(r,e);if(null!==s){let t=await o(h,i);return t=t.filter(t=>void 0!==t),a(s,t)}};return h(d)}const Te=(t,e)=>"."===t||null==e||0===e.length||"."===e||(e.length>=t.length?e.startsWith(t):t.startsWith(e));async function Ce({fs:t,cache:e,onProgress:i,dir:r,gitdir:s,remote:n,ref:a,filepaths:o,noCheckout:c,noUpdateHead:d,dryRun:l,force:h,track:f=!0}){let u;try{u=await mt.resolve({fs:t,gitdir:s,ref:a})}catch(e){if("HEAD"===a)throw e;const i=`${n}/${a}`;if(u=await mt.resolve({fs:t,gitdir:s,ref:i}),f){const e=await ft.get({fs:t,gitdir:s});await e.set(`branch.${a}.remote`,n),await e.set(`branch.${a}.merge`,"refs/heads/"+a),await ft.save({fs:t,gitdir:s,config:e})}await mt.writeRef({fs:t,gitdir:s,ref:"refs/heads/"+a,value:u})}if(!c){let n;try{n=await async function({fs:t,cache:e,onProgress:i,dir:r,gitdir:s,ref:n,force:a,filepaths:o}){let c=0;return Me({fs:t,cache:e,dir:r,gitdir:s,trees:[pe({ref:n}),we(),z()],map:async function(t,[e,r,s]){if("."===t)return;if(o&&!o.some(e=>Te(t,e)))return null;i&&await i({phase:"Analyzing workdir",loaded:++c});switch([!!s,!!e,!!r].map(Number).join("")){case"000":return;case"001":return a&&o&&o.includes(t)?["delete",t]:void 0;case"010":switch(await e.type()){case"tree":return["mkdir",t];case"blob":return["create",t,await e.oid(),await e.mode()];case"commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error","new entry Unhandled type "+await e.type()]}case"011":switch(`${await e.type()}-${await r.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",t];case"blob-blob":return await e.oid()!==await r.oid()?a?["update",t,await e.oid(),await e.mode(),await e.mode()!==await r.mode()]:["conflict",t]:await e.mode()!==await r.mode()?a?["update",t,await e.oid(),await e.mode(),!0]:["conflict",t]:["create-index",t,await e.oid(),await e.mode()];case"commit-tree":return;case"commit-blob":return["conflict",t];default:return["error","new entry Unhandled type "+e.type]}case"100":return["delete-index",t];case"101":switch(await s.type()){case"tree":return["rmdir",t];case"blob":return await s.oid()!==await r.oid()?a?["delete",t]:["conflict",t]:["delete",t];case"commit":return["rmdir-index",t];default:return["error","delete entry Unhandled type "+await s.type()]}case"110":case"111":switch(`${await s.type()}-${await e.type()}`){case"tree-tree":return;case"blob-blob":if(await s.oid()===await e.oid()&&await s.mode()===await e.mode()&&!a)return;if(r){if(await r.oid()!==await s.oid()&&await r.oid()!==await e.oid())return a?["update",t,await e.oid(),await e.mode(),await e.mode()!==await r.mode()]:["conflict",t]}else if(a)return["update",t,await e.oid(),await e.mode(),await e.mode()!==await s.mode()];return await e.mode()!==await s.mode()?["update",t,await e.oid(),await e.mode(),!0]:await e.oid()!==await s.oid()?["update",t,await e.oid(),await e.mode(),!1]:void 0;case"tree-blob":return["update-dir-to-blob",t,await e.oid()];case"blob-tree":return["update-blob-to-tree",t];case"commit-commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error",`update entry Unhandled type ${await s.type()}-${await e.type()}`]}}},reduce:async function(t,e){return e=Ne(e),t?t&&"rmdir"===t[0]?(e.push(t),e):(e.unshift(t),e):e}})}({fs:t,cache:e,onProgress:i,dir:r,gitdir:s,ref:a,force:h,filepaths:o})}catch(t){throw t instanceof H&&t.data.what===u?new Ct(a,u):t}const c=n.filter(([t])=>"conflict"===t).map(([t,e])=>e);if(c.length>0)throw new Tt(c);const d=n.filter(([t])=>"error"===t).map(([t,e])=>e);if(d.length>0)throw new _(d.join(", "));if(l)return;let f=0;const p=n.length;await U.acquire({fs:t,gitdir:s,cache:e},(async function(e){await Promise.all(n.filter(([t])=>"delete"===t||"delete-index"===t).map((async function([s,n]){const a=`${r}/${n}`;"delete"===s&&await t.rm(a),e.delete({filepath:n}),i&&await i({phase:"Updating workdir",loaded:++f,total:p})})))})),await U.acquire({fs:t,gitdir:s,cache:e},(async function(e){for(const[s,a]of n)if("rmdir"===s||"rmdir-index"===s){const n=`${r}/${a}`;try{"rmdir-index"===s&&e.delete({filepath:a}),await t.rmdir(n),i&&await i({phase:"Updating workdir",loaded:++f,total:p})}catch(t){if("ENOTEMPTY"!==t.code)throw t;console.log(`Did not delete ${a} because directory is not empty`)}}})),await Promise.all(n.filter(([t])=>"mkdir"===t||"mkdir-index"===t).map((async function([e,s]){const n=`${r}/${s}`;await t.mkdir(n),i&&await i({phase:"Updating workdir",loaded:++f,total:p})}))),await U.acquire({fs:t,gitdir:s,cache:e},(async function(a){await Promise.all(n.filter(([t])=>"create"===t||"create-index"===t||"update"===t||"mkdir-index"===t).map((async function([n,o,c,d,l]){const h=`${r}/${o}`;try{if("create-index"!==n&&"mkdir-index"!==n){const{object:i}=await Dt({fs:t,cache:e,gitdir:s,oid:c});if(l&&await t.rm(h),33188===d)await t.write(h,i);else if(33261===d)await t.write(h,i,{mode:511});else{if(40960!==d)throw new _(`Invalid mode 0o${d.toString(8)} detected in blob ${c}`);await t.writelink(h,i)}}const r=await t.lstat(h);33261===d&&(r.mode=493),"mkdir-index"===n&&(r.mode=57344),a.insert({filepath:o,stats:r,oid:c}),i&&await i({phase:"Updating workdir",loaded:++f,total:p})}catch(t){console.log(t)}})))}))}if(!d){const e=await mt.expand({fs:t,gitdir:s,ref:a});e.startsWith("refs/heads")?await mt.writeSymbolicRef({fs:t,gitdir:s,ref:"HEAD",value:e}):await mt.writeRef({fs:t,gitdir:s,ref:"HEAD",value:u})}}async function Be({fs:t,onProgress:e,dir:i,gitdir:r=J(i,".git"),remote:s="origin",ref:n,filepaths:a,noCheckout:o=!1,noUpdateHead:c=void 0===n,dryRun:d=!1,force:l=!1,track:h=!0,cache:f={}}){try{xe("fs",t),xe("dir",i),xe("gitdir",r);const u=n||"HEAD";return await Ce({fs:new be(t),cache:f,onProgress:e,dir:i,gitdir:r,remote:s,ref:u,filepaths:a,noCheckout:o,noUpdateHead:c,dryRun:d,force:l,track:h})}catch(t){throw t.caller="git.checkout",t}}const Fe=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function ze(t){const e=Fe.exec(t);return e?"remotes/"===e[1]&&t.endsWith("/HEAD")?e[2].slice(0,-5):e[2]:t}async function He({fs:t,gitdir:e,fullname:i=!1,test:r=!1}){const s=await mt.resolve({fs:t,gitdir:e,ref:"HEAD",depth:2});if(r)try{await mt.resolve({fs:t,gitdir:e,ref:s})}catch(t){return}if(s.startsWith("refs/"))return i?s:ze(s)}function Ge({username:e="",password:i=""}){return"Basic "+t.from(`${e}:${i}`).toString("base64")}async function We(t,e){const i=$t(t);for(;;){const{value:t,done:r}=await i.next();if(t&&await e(t),r)break}i.return&&i.return()}async function qe(t){let e=0;const i=[];await We(t,t=>{i.push(t),e+=t.byteLength});const r=new Uint8Array(e);let s=0;for(const t of i)r.set(t,s),s+=t.byteLength;return r}function Le(t){let e=t.match(/^https?:\/\/([^/]+)@/);if(null==e)return{url:t,auth:{}};e=e[1];const[i,r]=e.split(":");return{url:t=t.replace(e+"@",""),auth:{username:i,password:r}}}function Ke(t,e){const i=e.toString(16);return"0".repeat(t-i.length)+i}class Ve{static flush(){return t.from("0000","utf8")}static delim(){return t.from("0001","utf8")}static encode(e){"string"==typeof e&&(e=t.from(e));const i=Ke(4,e.length+4);return t.concat([t.from(i,"utf8"),e])}static streamReader(t){const e=new St(t);return async function(){try{let t=await e.read(4);if(null==t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;if(1===t)return null;const i=await e.read(t-4);return null==i||i}catch(t){return console.log("error",t),!0}}}}async function Ye(t){const e={};let i;for(;i=await t(),!0!==i;){if(null===i)continue;i=i.toString("utf8").replace(/\n$/,"");const t=i.indexOf("=");if(t>-1){const r=i.slice(0,t),s=i.slice(t+1);e[r]=s}else e[i]=!0}return{protocolVersion:2,capabilities2:e}}async function Ze(t,{service:e}){const i=new Set,r=new Map,s=new Map,n=Ve.streamReader(t);let a=await n();for(;null===a;)a=await n();if(!0===a)throw new Bt;if(a.includes("version 2"))return Ye(n);if(a.toString("utf8").replace(/\n$/,"")!=="# service="+e)throw new Jt(`# service=${e}\\n`,a.toString("utf8"));let o=await n();for(;null===o;)o=await n();if(!0===o)return{capabilities:i,refs:r,symrefs:s};if(o=o.toString("utf8"),o.includes("version 2"))return Ye(n);const[c,d]=Je(o,"\0","\\x00");d.split(" ").map(t=>i.add(t));const[l,h]=Je(c," "," ");for(r.set(h,l);;){const t=await n();if(!0===t)break;if(null!==t){const[e,i]=Je(t.toString("utf8")," "," ");r.set(i,e)}}for(const t of i)if(t.startsWith("symref=")){const e=t.match(/symref=([^:]+):(.*)/);3===e.length&&s.set(e[1],e[2])}return{protocolVersion:1,capabilities:i,refs:r,symrefs:s}}function Je(t,e,i){const r=t.trim().split(e);if(2!==r.length)throw new Jt(`Two strings separated by '${i}'`,t.toString("utf8"));return r}const Xe=(t,e)=>t.endsWith("?")?`${t}${e}`:`${t}/${e.replace(/^https?:\/\//,"")}`,Qe=(t,e)=>{(e.username||e.password)&&(t.Authorization=Ge(e)),e.headers&&Object.assign(t,e.headers)},ti=async e=>{try{const i=t.from(await qe(e.body)),r=i.toString("utf8");return{preview:r.length<256?r:r.slice(0,256)+"...",response:r,data:i}}catch(t){return{}}};class ei{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:i,onAuthSuccess:r,onAuthFailure:s,corsProxy:n,service:a,url:o,headers:c,protocolVersion:d}){let{url:l,auth:h}=Le(o);const f=n?Xe(n,l):l;let u,p;(h.username||h.password)&&(c.Authorization=Ge(h)),2===d&&(c["Git-Protocol"]="version=2");let m=!1;do{if(u=await t.request({onProgress:e,method:"GET",url:`${f}/info/refs?service=${a}`,headers:c}),p=!1,401===u.statusCode||203===u.statusCode){const t=m?s:i;if(t){if(h=await t(l,{...h,headers:{...c}}),h&&h.cancel)throw new re;h&&(Qe(c,h),m=!0,p=!0)}}else 200===u.statusCode&&m&&r&&await r(l,h)}while(p);if(200!==u.statusCode){const{response:t}=await ti(u);throw new Ht(u.statusCode,u.statusMessage,t)}if(u.headers["content-type"]===`application/x-${a}-advertisement`){const t=await Ze(u.body,{service:a});return t.auth=h,t}{const{preview:t,response:e,data:i}=await ti(u);try{const t=await Ze([i],{service:a});return t.auth=h,t}catch(i){throw new te(t,e)}}}static async connect({http:t,onProgress:e,corsProxy:i,service:r,url:s,auth:n,body:a,headers:o}){const c=Le(s);c&&(s=c.url),i&&(s=Xe(i,s)),o["content-type"]=`application/x-${r}-request`,o.accept=`application/x-${r}-result`,Qe(o,n);const d=await t.request({onProgress:e,method:"POST",url:`${s}/${r}`,body:a,headers:o});if(200!==d.statusCode){const{response:t}=ti(d);throw new Ht(d.statusCode,d.statusMessage,t)}return d}}class ii{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",ei),e.set("https",ei);const i=function({url:t}){if(t.startsWith("git@"))return{transport:"ssh",address:t};const e=t.match(/(\w+)(:\/\/|::)(.*)/);return null!==e?"://"===e[2]?{transport:e[1],address:e[0]}:"::"===e[2]?{transport:e[1],address:e[3]}:void 0:void 0}({url:t});if(!i)throw new ie(t);if(e.has(i.transport))return e.get(i.transport);throw new ee(t,i.transport,"ssh"===i.transport?function(t){return t=(t=t.replace(/^git@([^:]+):/,"https://$1/")).replace(/^ssh:\/\//,"https://")}(t):void 0)}}let ri=null;class si{static async read({fs:t,gitdir:e}){null===ri&&(ri=new s.a);const i=J(e,"shallow"),r=new Set;return await ri.acquire(i,(async function(){const e=await t.read(i,{encoding:"utf8"});return null===e||""===e.trim()?r:void e.trim().split("\n").map(t=>r.add(t))})),r}static async write({fs:t,gitdir:e,oids:i}){null===ri&&(ri=new s.a);const r=J(e,"shallow");if(i.size>0){const e=[...i].join("\n")+"\n";await ri.acquire(r,(async function(){await t.write(r,e,{encoding:"utf8"})}))}else await ri.acquire(r,(async function(){await t.rm(r)}))}}async function ni({fs:t,cache:e,gitdir:i,oid:r,format:s="content"}){const n=r=>Dt({fs:t,cache:e,gitdir:i,oid:r});let a=await async function({fs:t,gitdir:e,oid:i}){const r=`objects/${i.slice(0,2)}/${i.slice(2)}`;return t.exists(`${e}/${r}`)}({fs:t,gitdir:i,oid:r});return a||(a=await async function({fs:t,cache:e,gitdir:i,oid:r,getExternalRefDelta:s}){let n=await t.readdir(J(i,"objects/pack"));n=n.filter(t=>t.endsWith(".idx"));for(const a of n){const n=`${i}/objects/pack/${a}`,o=await Nt({fs:t,cache:e,filename:n,getExternalRefDelta:s});if(o.error)throw new _(o.error);if(o.offsets.has(r))return!0}return!1}({fs:t,cache:e,gitdir:i,oid:r,getExternalRefDelta:n})),a}function ai(t,e){const i=t.map(t=>t.split("=",1)[0]);return e.filter(t=>{const e=t.split("=",1)[0];return i.includes(e)})}const oi="1.19.1",ci="git/isomorphic-git@1.19.1";class di{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this._ended=!0,this.error=t}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function li(t){const e=t.indexOf("\r"),i=t.indexOf("\n");return-1===e&&-1===i?-1:-1===e?i+1:-1===i?e+1:i===e+1?i+1:Math.min(e,i)+1}function hi(t){const e=new di;let i="";return(async()=>{await We(t,t=>{for(t=t.toString("utf8"),i+=t;;){const t=li(i);if(-1===t)break;e.write(i.slice(0,t)),i=i.slice(t)}}),i.length>0&&e.write(i),e.end()})(),e}class fi{static demux(t){const e=Ve.streamReader(t),i=new di,r=new di,s=new di,n=async function(){const t=await e();if(null===t)return n();if(!0===t)return i.end(),s.end(),void r.end();switch(t[0]){case 1:r.write(t.slice(1));break;case 2:s.write(t.slice(1));break;case 3:{const e=t.slice(1);return s.write(e),void r.destroy(new Error(e.toString("utf8")))}default:i.write(t.slice(0))}n()};return n(),{packetlines:i,packfile:r,progress:s}}}async function ui({fs:e,cache:i,http:r,onProgress:s,onMessage:n,onAuth:a,onAuthSuccess:o,onAuthFailure:c,gitdir:d,ref:l,remoteRef:h,remote:f,url:u,corsProxy:p,depth:m=null,since:w=null,exclude:g=[],relative:y=!1,tags:b=!1,singleBranch:_=!1,headers:v={},prune:k=!1,pruneTags:x=!1}){const E=l||await He({fs:e,gitdir:d,test:!0}),$=await ft.get({fs:e,gitdir:d}),S=f||E&&await $.get(`branch.${E}.remote`)||"origin",P=u||await $.get(`remote.${S}.url`);if(void 0===P)throw new Yt("remote OR url");const I=h||E&&await $.get(`branch.${E}.merge`)||l||"HEAD";void 0===p&&(p=await $.get("http.corsProxy"));const j=ii.getRemoteHelperFor({url:P}),O=await j.discover({http:r,onAuth:a,onAuthSuccess:o,onAuthFailure:c,corsProxy:p,service:"git-upload-pack",url:P,headers:v,protocolVersion:1}),R=O.auth,A=O.refs;if(0===A.size)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(null!==m&&!O.capabilities.has("shallow"))throw new Qt("shallow","depth");if(null!==w&&!O.capabilities.has("deepen-since"))throw new Qt("deepen-since","since");if(g.length>0&&!O.capabilities.has("deepen-not"))throw new Qt("deepen-not","exclude");if(!0===y&&!O.capabilities.has("deepen-relative"))throw new Qt("deepen-relative","relative");const{oid:N,fullref:D}=mt.resolveAgainstMap({ref:I,map:A});for(const t of A.keys())t===D||"HEAD"===t||t.startsWith("refs/heads/")||b&&t.startsWith("refs/tags/")||A.delete(t);const U=ai([...O.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta","agent="+ci]);y&&U.push("deepen-relative");const M=_?[N]:A.values(),T=_?[E]:await mt.listRefs({fs:e,gitdir:d,filepath:"refs"});let C=[];for(let t of T)try{t=await mt.expand({fs:e,gitdir:d,ref:t});const r=await mt.resolve({fs:e,gitdir:d,ref:t});await ni({fs:e,cache:i,gitdir:d,oid:r})&&C.push(r)}catch(t){}C=[...new Set(C)];const B=await si.read({fs:e,gitdir:d}),F=function({capabilities:t=[],wants:e=[],haves:i=[],shallows:r=[],depth:s=null,since:n=null,exclude:a=[]}){const o=[];e=[...new Set(e)];let c=" "+t.join(" ");for(const t of e)o.push(Ve.encode(`want ${t}${c}\n`)),c="";for(const t of r)o.push(Ve.encode(`shallow ${t}\n`));null!==s&&o.push(Ve.encode(`deepen ${s}\n`)),null!==n&&o.push(Ve.encode(`deepen-since ${Math.floor(n.valueOf()/1e3)}\n`));for(const t of a)o.push(Ve.encode(`deepen-not ${t}\n`));o.push(Ve.flush());for(const t of i)o.push(Ve.encode(`have ${t}\n`));return o.push(Ve.encode("done\n")),o}({capabilities:U,wants:M,haves:C,shallows:O.capabilities.has("shallow")?[...B]:[],depth:m,since:w,exclude:g}),z=t.from(await qe(F)),H=await j.connect({http:r,onProgress:s,corsProxy:p,service:"git-upload-pack",url:P,auth:R,body:[z],headers:v}),G=await async function(t){const{packetlines:e,packfile:i,progress:r}=fi.demux(t),s=[],n=[],a=[];let o=!1,c=!1;return new Promise((t,d)=>{We(e,e=>{const l=e.toString("utf8").trim();if(l.startsWith("shallow")){const t=l.slice(-41).trim();40!==t.length&&d(new W(t)),s.push(t)}else if(l.startsWith("unshallow")){const t=l.slice(-41).trim();40!==t.length&&d(new W(t)),n.push(t)}else if(l.startsWith("ACK")){const[,t,e]=l.split(" ");a.push({oid:t,status:e}),e||(c=!0)}else l.startsWith("NAK")&&(o=!0,c=!0);c&&t({shallows:s,unshallows:n,acks:a,nak:o,packfile:i,progress:r})})})}(H.body);H.headers&&(G.headers=H.headers);for(const t of G.shallows)if(!B.has(t))try{const{object:r}=await Dt({fs:e,cache:i,gitdir:d,oid:t}),s=new he(r),n=await Promise.all(s.headers().parent.map(t=>ni({fs:e,cache:i,gitdir:d,oid:t})));0===n.length||n.every(t=>t)||B.add(t)}catch(e){B.add(t)}for(const t of G.unshallows)B.delete(t);if(await si.write({fs:e,gitdir:d,oids:B}),_){const t=new Map([[D,N]]),i=new Map;let r=10,s=D;for(;r--;){const t=O.symrefs.get(s);if(void 0===t)break;i.set(s,t),s=t}const n=A.get(s);n&&t.set(s,n);const{pruned:a}=await mt.updateRemoteRefs({fs:e,gitdir:d,remote:S,refs:t,symrefs:i,tags:b,prune:k});k&&(G.pruned=a)}else{const{pruned:t}=await mt.updateRemoteRefs({fs:e,gitdir:d,remote:S,refs:A,symrefs:O.symrefs,tags:b,prune:k,pruneTags:x});k&&(G.pruned=t)}if(G.HEAD=O.symrefs.get("HEAD"),void 0===G.HEAD){const{oid:t}=mt.resolveAgainstMap({ref:"HEAD",map:A});for(const[e,i]of A.entries())if("HEAD"!==e&&i===t){G.HEAD=e;break}}const q=D.startsWith("refs/tags")?"tag":"branch";if(G.FETCH_HEAD={oid:N,description:`${q} '${ze(D)}' of ${P}`},s||n){We(hi(G.progress),async t=>{if(n&&await n(t),s){const e=t.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);e&&await s({phase:e[1].trim(),loaded:parseInt(e[2],10),total:parseInt(e[3],10)})}})}const L=t.from(await qe(G.packfile)),K=L.slice(-20).toString("hex"),V={defaultBranch:G.HEAD,fetchHead:G.FETCH_HEAD.oid,fetchHeadDescription:G.FETCH_HEAD.description};if(G.headers&&(V.headers=G.headers),k&&(V.pruned=G.pruned),""!==K&&"5041434b0000000200000000"!==L.slice(0,12).toString("hex")){V.packfile=`objects/pack/pack-${K}.pack`;const t=J(d,V.packfile);await e.write(t,L);const r=t=>Dt({fs:e,cache:i,gitdir:d,oid:t}),n=await Rt.fromPack({pack:L,getExternalRefDelta:r,onProgress:s});await e.write(t.replace(/\.pack$/,".idx"),await n.toBuffer())}return V}async function pi({fs:t,bare:e=!1,dir:i,gitdir:r=(e?i:J(i,".git")),defaultBranch:s="master"}){if(await t.exists(r+"/config"))return;let n=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];n=n.map(t=>r+"/"+t);for(const e of n)await t.mkdir(e);await t.write(r+"/config",`[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n\tbare = ${e}\n`+(e?"":"\tlogallrefupdates = true\n")+"\tsymlinks = false\n\tignorecase = true\n"),await t.write(r+"/HEAD",`ref: refs/heads/${s}\n`)}async function mi({fs:t,onSign:e,dir:i,gitdir:r=J(i,".git"),message:s,author:n,committer:a,signingKey:o,dryRun:c=!1,noUpdateBranch:d=!1,ref:l,parent:h,tree:f,cache:u={}}){try{xe("fs",t),xe("message",s),o&&xe("onSign",e);const i=new be(t),p=await Ie({fs:i,gitdir:r,author:n});if(!p)throw new Vt("author");const m=await je({fs:i,gitdir:r,author:p,committer:a});if(!m)throw new Vt("committer");return await $e({fs:i,cache:u,onSign:e,gitdir:r,message:s,author:p,committer:m,signingKey:o,dryRun:c,noUpdateBranch:d,ref:l,parent:h,tree:f})}catch(t){throw t.caller="git.commit",t}}async function wi({fs:t,dir:e,gitdir:i=J(e,".git"),fullname:r=!1,test:s=!1}){try{return xe("fs",t),xe("gitdir",i),await He({fs:new be(t),gitdir:i,fullname:r,test:s})}catch(t){throw t.caller="git.currentBranch",t}}async function gi({fs:t,cache:e,gitdir:i,oids:r}){const s={},n=r.length;let a=r.map((t,e)=>({index:e,oid:t}));for(;a.length;){const r=new Set;for(const{oid:t,index:e}of a)s[t]||(s[t]=new Set),s[t].add(e),s[t].size===n&&r.add(t);if(r.size>0)return[...r];const o=new Map;for(const{oid:r,index:n}of a)try{const{object:a}=await Dt({fs:t,cache:e,gitdir:i,oid:r}),c=he.from(a),{parent:d}=c.parseHeaders();for(const t of d)s[t]&&s[t].has(n)||o.set(t+":"+n,{oid:t,index:n})}catch(t){}a=Array.from(o.values())}return[]}const yi=/^.*(\r?\n|$)/gm;function bi({branches:t,contents:e}){const i=t[1],r=t[2],s=e[0],n=e[1],a=e[2],o=n.match(yi),c=s.match(yi),d=a.match(yi),l=y()(o,c,d);let h="",f=!0;for(const t of l)t.ok&&(h+=t.ok.join("")),t.conflict&&(f=!1,h+=`${"<".repeat(7)} ${i}\n`,h+=t.conflict.a.join(""),h+="=".repeat(7)+"\n",h+=t.conflict.b.join(""),h+=`${">".repeat(7)} ${r}\n`);return{cleanMerge:f,mergedText:h}}async function _i({fs:e,cache:i,dir:r,gitdir:s=J(r,".git"),ourOid:n,baseOid:a,theirOid:o,ourName:c="ours",baseName:d="base",theirName:l="theirs",dryRun:h=!1,abortOnConflict:f=!0,mergeDriver:u}){const p=pe({ref:n}),m=pe({ref:a}),w=pe({ref:o}),g=[];let y=!0;const b=await Me({fs:e,cache:i,dir:r,gitdir:s,trees:[p,m,w],map:async function(i,[r,n,a]){const o=M(i);switch(`${await vi(r,n)}-${await vi(a,n)}`){case"false-false":return{mode:await n.mode(),path:o,oid:await n.oid(),type:await n.type()};case"false-true":return a?{mode:await a.mode(),path:o,oid:await a.oid(),type:await a.type()}:void 0;case"true-false":return r?{mode:await r.mode(),path:o,oid:await r.oid(),type:await r.type()}:void 0;case"true-true":if(r&&n&&a&&"blob"===await r.type()&&"blob"===await n.type()&&"blob"===await a.type())return async function({fs:e,gitdir:i,path:r,ours:s,base:n,theirs:a,ourName:o,theirName:c,baseName:d,dryRun:l,mergeDriver:h=bi}){const f=await n.mode()===await s.mode()?await a.mode():await s.mode();if(await s.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:f,path:r,oid:await s.oid(),type:"blob"}};if(await s.oid()===await n.oid())return{cleanMerge:!0,mergeResult:{mode:f,path:r,oid:await a.oid(),type:"blob"}};if(await a.oid()===await n.oid())return{cleanMerge:!0,mergeResult:{mode:f,path:r,oid:await s.oid(),type:"blob"}};const u=t.from(await s.content()).toString("utf8"),p=t.from(await n.content()).toString("utf8"),m=t.from(await a.content()).toString("utf8"),{mergedText:w,cleanMerge:g}=await h({branches:[d,o,c],contents:[p,u,m],path:r}),y=await ke({fs:e,gitdir:i,type:"blob",object:t.from(w,"utf8"),dryRun:l});return{cleanMerge:g,mergeResult:{mode:f,path:r,oid:y,type:"blob"}}}({fs:e,gitdir:s,path:o,ours:r,base:n,theirs:a,ourName:c,baseName:d,theirName:l,mergeDriver:u}).then(t=>(y=y&&t.cleanMerge,g.push(i),t.mergeResult));throw new Lt}},reduce:async(t,i)=>{const r=i.filter(Boolean);if(t&&(!t||"tree"!==t.type||0!==r.length)){if(r.length>0){const i=new _t(r).toObject(),n=await ke({fs:e,gitdir:s,type:"tree",object:i,dryRun:h});t.oid=n}return t}}});if(!y)throw r&&!f&&await Me({fs:e,cache:i,dir:r,gitdir:s,trees:[pe({ref:b.oid})],map:async function(t,[i]){const s=`${r}/${t}`;if("blob"===await i.type()){const t=await i.mode(),r=(new TextDecoder).decode(await i.content());await e.write(s,r,{mode:t})}return!0}}),new Kt(g);return b.oid}async function vi(t,e){return!(!t&&!e)&&(!(!t||e)||(!(t||!e)||("tree"!==await t.type()||"tree"!==await e.type())&&(await t.type()!==await e.type()||await t.mode()!==await e.mode()||await t.oid()!==await e.oid())))}async function ki({fs:t,cache:e,dir:i,gitdir:r,ours:s,theirs:n,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:c=!1,noUpdateBranch:d=!1,abortOnConflict:l=!0,message:h,author:f,committer:u,signingKey:p,onSign:m,mergeDriver:w}){void 0===s&&(s=await He({fs:t,gitdir:r,fullname:!0})),s=await mt.expand({fs:t,gitdir:r,ref:s}),n=await mt.expand({fs:t,gitdir:r,ref:n});const g=await mt.resolve({fs:t,gitdir:r,ref:s}),y=await mt.resolve({fs:t,gitdir:r,ref:n}),b=await gi({fs:t,cache:e,gitdir:r,oids:[g,y]});if(1!==b.length)throw new Lt;const _=b[0];if(_===y)return{oid:g,alreadyMerged:!0};if(a&&_===g)return c||d||await mt.writeRef({fs:t,gitdir:r,ref:s,value:y}),{oid:y,fastForward:!0};{if(o)throw new Ft;const a=await _i({fs:t,cache:e,dir:i,gitdir:r,ourOid:g,theirOid:y,baseOid:_,ourName:ze(s),baseName:"base",theirName:ze(n),dryRun:c,abortOnConflict:l,mergeDriver:w});h||(h=`Merge branch '${ze(n)}' into ${ze(s)}`);return{oid:await $e({fs:t,cache:e,gitdir:r,message:h,ref:s,tree:a,parent:[g,y],author:f,committer:u,signingKey:p,onSign:m,dryRun:c,noUpdateBranch:d}),tree:a,mergeCommit:!0}}}async function xi({fs:t,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:n,onAuthFailure:a,dir:o,gitdir:c=J(o,".git"),ref:d,remote:l,remoteRef:h,url:f,corsProxy:u,depth:p=null,since:m=null,exclude:w=[],relative:g=!1,tags:y=!1,singleBranch:b=!1,headers:_={},prune:v=!1,pruneTags:k=!1,cache:x={}}){try{return xe("fs",t),xe("http",e),xe("gitdir",c),await ui({fs:new be(t),cache:x,http:e,onProgress:i,onMessage:r,onAuth:s,onAuthSuccess:n,onAuthFailure:a,gitdir:c,ref:d,remote:l,remoteRef:h,url:f,corsProxy:u,depth:p,since:m,exclude:w,relative:g,tags:y,singleBranch:b,headers:_,prune:v,pruneTags:k})}catch(t){throw t.caller="git.fetch",t}}async function Ei({fs:t,dir:e,gitdir:i=J(e,".git"),path:r}){try{return xe("fs",t),xe("gitdir",i),xe("path",r),await Pe({fs:new be(t),gitdir:i,path:r})}catch(t){throw t.caller="git.getConfig",t}}function $i(t,e,i,r){const s=[];for(const[n,a]of t.refs){if(e&&!n.startsWith(e))continue;if(n.endsWith("^{}")){if(r){const t=n.replace("^{}",""),e=s[s.length-1],i=e.ref===t?e:s.find(e=>e.ref===t);if(void 0===i)throw new Error("I did not expect this to happen");i.peeled=a}continue}const o={ref:n,oid:a};i&&t.symrefs.has(n)&&(o.target=t.symrefs.get(n)),s.push(o)}return s}async function Si({object:e}){try{xe("object",e),e="string"==typeof e?t.from(e,"utf8"):t.from(e);const i="blob",{oid:r,object:s}=await async function({type:t,object:e,format:i="content",oid:r}){return"deflated"!==i&&("wrapped"!==i&&(e=vt.wrap({type:t,object:e})),r=await j(e)),{oid:r,object:e}}({type:"blob",format:"content",object:e});return{oid:r,type:i,object:new Uint8Array(s),format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Pi({fs:t,bare:e=!1,dir:i,gitdir:r=(e?i:J(i,".git")),defaultBranch:s="master"}){try{return xe("fs",t),xe("gitdir",r),e||xe("dir",i),await pi({fs:new be(t),bare:e,dir:i,gitdir:r,defaultBranch:s})}catch(t){throw t.caller="git.init",t}}async function Ii({fs:t,dir:e,gitdir:i=J(e,".git")}){try{return xe("fs",t),xe("gitdir",i),await async function({fs:t,gitdir:e}){const i=await ft.get({fs:t,gitdir:e}),r=await i.getSubsections("remote");return Promise.all(r.map(async t=>({remote:t,url:await i.get(`remote.${t}.url`)})))}({fs:new be(t),gitdir:i})}catch(t){throw t.caller="git.listRemotes",t}}async function ji({http:t,onAuth:e,onAuthSuccess:i,onAuthFailure:r,corsProxy:s,url:n,headers:a={},forPush:o=!1,protocolVersion:c=2,prefix:d,symrefs:l,peelTags:h}){try{xe("http",t),xe("url",n);const f=await ei.discover({http:t,onAuth:e,onAuthSuccess:i,onAuthFailure:r,corsProxy:s,service:o?"git-receive-pack":"git-upload-pack",url:n,headers:a,protocolVersion:c});if(1===f.protocolVersion)return $i(f,d,l,h);const u=await async function({prefix:t,symrefs:e,peelTags:i}){const r=[];return r.push(Ve.encode("command=ls-refs\n")),r.push(Ve.encode(`agent=${ci}\n`)),(i||e||t)&&r.push(Ve.delim()),i&&r.push(Ve.encode("peel")),e&&r.push(Ve.encode("symrefs")),t&&r.push(Ve.encode("ref-prefix "+t)),r.push(Ve.flush()),r}({prefix:d,symrefs:l,peelTags:h});return async function(t){const e=Ve.streamReader(t),i=[];let r;for(;r=await e(),!0!==r;){if(null===r)continue;r=r.toString("utf8").replace(/\n$/,"");const[t,e,...s]=r.split(" "),n={ref:e,oid:t};for(const t of s){const[e,i]=t.split(":");"symref-target"===e?n.target=i:"peeled"===e&&(n.peeled=i)}i.push(n)}return i}((await ei.connect({http:t,auth:f.auth,headers:a,corsProxy:s,service:o?"git-receive-pack":"git-upload-pack",url:n,body:u})).body)}catch(t){throw t.caller="git.listServerRefs",t}}async function Oi({fs:t,cache:e,gitdir:i,oid:r}){const{commit:s,oid:n}=await async function t({fs:e,cache:i,gitdir:r,oid:s}){const{type:n,object:a}=await Dt({fs:e,cache:i,gitdir:r,oid:s});if("tag"===n)return t({fs:e,cache:i,gitdir:r,oid:s=de.from(a).parse().object});if("commit"!==n)throw new G(s,n,"commit");return{commit:he.from(a),oid:s}}({fs:t,cache:e,gitdir:i,oid:r});return{oid:n,commit:s.parse(),payload:s.withoutSignature()}}function Ri(t,e){return t.committer.timestamp-e.committer.timestamp}async function Ai({fs:t,cache:e,gitdir:i,oid:r,fileId:s}){if("e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"===s)return;const n=r;let a;const o=await fe({fs:t,cache:e,gitdir:i,oid:r}),c=o.tree;return s===o.oid?a=o.path:(a=await async function t({fs:e,cache:i,gitdir:r,tree:s,fileId:n,oid:a,filepaths:o=[],parentPath:c=""}){const d=s.entries().map((function(s){let d;return s.oid===n?(d=J(c,s.path),o.push(d)):"tree"===s.type&&(d=Dt({fs:e,cache:i,gitdir:r,oid:s.oid}).then((function({object:d}){return t({fs:e,cache:i,gitdir:r,tree:_t.from(d),fileId:n,oid:a,filepaths:o,parentPath:J(c,s.path)})}))),d}));return await Promise.all(d),o}({fs:t,cache:e,gitdir:i,tree:c,fileId:s,oid:n}),Array.isArray(a)&&(0===a.length?a=void 0:1===a.length&&(a=a[0]))),a}async function Ni({fs:t,dir:e,gitdir:i=J(e,".git"),filepath:r,ref:s="HEAD",depth:n,since:a,force:o,follow:c,cache:d={}}){try{return xe("fs",t),xe("gitdir",i),xe("ref",s),await async function({fs:t,cache:e,gitdir:i,filepath:r,ref:s,depth:n,since:a,force:o,follow:c}){const d=void 0===a?void 0:Math.floor(a.valueOf()/1e3),l=[],h=await si.read({fs:t,gitdir:i}),f=await mt.resolve({fs:t,gitdir:i,ref:s}),u=[await Oi({fs:t,cache:e,gitdir:i,oid:f})];let p,m,w;function g(t){w&&r&&l.push(t)}for(;u.length>0;){const s=u.pop();if(void 0!==d&&s.commit.committer.timestamp<=d)break;if(r){let n;try{n=await Se({fs:t,cache:e,gitdir:i,oid:s.commit.tree,filepath:r}),m&&p!==n&&l.push(m),p=n,m=s,w=!0}catch(n){if(!(n instanceof H))throw n;{let a=c&&p;if(a&&(a=await Ai({fs:t,cache:e,gitdir:i,oid:s.commit.tree,fileId:p}),a))if(Array.isArray(a)){if(m){const s=await Ai({fs:t,cache:e,gitdir:i,oid:m.commit.tree,fileId:p});if(Array.isArray(s)){if(a=a.filter(t=>-1===s.indexOf(t)),1!==a.length){a=!1,m&&l.push(m);break}a=a[0],r=a,m&&l.push(m)}}}else r=a,m&&l.push(m);if(!a){if(w&&p&&(l.push(m),!o))break;if(!o&&!c)throw n}m=s,w=!1}}}else l.push(s);if(void 0!==n&&l.length===n){g(s);break}if(!h.has(s.oid))for(const r of s.commit.parent){const s=await Oi({fs:t,cache:e,gitdir:i,oid:r});u.map(t=>t.oid).includes(s.oid)||u.push(s)}0===u.length&&g(s),u.sort((t,e)=>Ri(t.commit,e.commit))}return l}({fs:new be(t),cache:d,gitdir:i,filepath:r,ref:s,depth:n,since:a,force:o,follow:c})}catch(t){throw t.caller="git.log",t}}async function Di({fs:t,onSign:e,dir:i,gitdir:r=J(i,".git"),ours:s,theirs:n,fastForward:a=!0,fastForwardOnly:o=!1,dryRun:c=!1,noUpdateBranch:d=!1,abortOnConflict:l=!0,message:h,author:f,committer:u,signingKey:p,cache:m={},mergeDriver:w}){try{xe("fs",t),p&&xe("onSign",e);const g=new be(t),y=await Ie({fs:g,gitdir:r,author:f});if(!(y||o&&a))throw new Vt("author");const b=await je({fs:g,gitdir:r,author:y,committer:u});if(!(b||o&&a))throw new Vt("committer");return await ki({fs:g,cache:m,dir:i,gitdir:r,ours:s,theirs:n,fastForward:a,fastForwardOnly:o,dryRun:c,noUpdateBranch:d,abortOnConflict:l,message:h,author:y,committer:b,signingKey:p,onSign:e,mergeDriver:w})}catch(t){throw t.caller="git.merge",t}}async function Ui({fs:t,cache:e,gitdir:i,oid:r,filepath:s}){void 0!==s&&(r=await Se({fs:t,cache:e,gitdir:i,oid:r,filepath:s}));return await async function t({fs:e,cache:i,gitdir:r,oid:s}){const{type:n,object:a}=await Dt({fs:e,cache:i,gitdir:r,oid:s});if("tag"===n)return t({fs:e,cache:i,gitdir:r,oid:s=de.from(a).parse().object});if("blob"!==n)throw new G(s,n,"blob");return{oid:s,blob:new Uint8Array(a)}}({fs:t,cache:e,gitdir:i,oid:r})}async function Mi({fs:t,dir:e,gitdir:i=J(e,".git"),oid:r,filepath:s,cache:n={}}){try{return xe("fs",t),xe("gitdir",i),xe("oid",r),await Ui({fs:new be(t),cache:n,gitdir:i,oid:r,filepath:s})}catch(t){throw t.caller="git.readBlob",t}}async function Ti({fs:t,dir:e,gitdir:i=J(e,".git"),filepath:r,cache:s={}}){try{xe("fs",t),xe("gitdir",i),xe("filepath",r),await U.acquire({fs:new be(t),gitdir:i,cache:s},(async function(t){t.delete({filepath:r})}))}catch(t){throw t.caller="git.remove",t}}async function Ci({gitdir:t,type:e,object:i}){return j(vt.wrap({type:e,object:i}))}async function Bi({fs:t,dir:e,gitdir:i=J(e,".git"),filepath:r,ref:s,cache:n={}}){try{xe("fs",t),xe("gitdir",i),xe("filepath",r);const a=new be(t);let o,c;try{o=await mt.resolve({fs:a,gitdir:i,ref:s||"HEAD"})}catch(t){if(s)throw t}if(o)try{o=await Se({fs:a,cache:n,gitdir:i,oid:o,filepath:r})}catch(t){o=null}let d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const l=e&&await a.read(J(e,r));l&&(c=await Ci({gitdir:i,type:"blob",object:l}),o===c&&(d=await a.lstat(J(e,r)))),await U.acquire({fs:a,gitdir:i,cache:n},(async function(t){t.delete({filepath:r}),o&&t.insert({filepath:r,stats:d,oid:o})}))}catch(t){throw t.caller="git.reset",t}}async function Fi({fs:t,dir:e,gitdir:i=J(e,".git"),ref:r,depth:s}){try{xe("fs",t),xe("gitdir",i),xe("ref",r);return await mt.resolve({fs:new be(t),gitdir:i,ref:r,depth:s})}catch(t){throw t.caller="git.resolveRef",t}}async function zi({fs:t,dir:e,gitdir:i=J(e,".git"),path:r,value:s,append:n=!1}){try{xe("fs",t),xe("gitdir",i),xe("path",r);const e=new be(t),a=await ft.get({fs:e,gitdir:i});n?await a.append(r,s):await a.set(r,s),await ft.save({fs:e,gitdir:i,config:a})}catch(t){throw t.caller="git.setConfig",t}}async function Hi({fs:t,dir:e,gitdir:i=J(e,".git"),ref:r="HEAD",filepaths:s=["."],filter:n,cache:a={},ignored:o=!1}){try{xe("fs",t),xe("gitdir",i),xe("ref",r);const c=new be(t);return await Me({fs:c,cache:a,dir:e,gitdir:i,trees:[pe({ref:r}),we(),z()],map:async function(t,[i,r,a]){if(!i&&!a&&r&&!o){if(await ge.isIgnored({fs:c,dir:e,filepath:t}))return null}if(!s.some(e=>Te(t,e)))return null;if(n&&!n(t))return;const[d,l,h]=await Promise.all([i&&i.type(),r&&r.type(),a&&a.type()]),f=[d,l,h].includes("blob");if(("tree"===d||"special"===d)&&!f)return;if("commit"===d)return null;if(("tree"===l||"special"===l)&&!f)return;if("commit"===h)return null;if(("tree"===h||"special"===h)&&!f)return;const u="blob"===d?await i.oid():void 0,p="blob"===h?await a.oid():void 0;let m;"blob"!==d&&"blob"===l&&"blob"!==h?m="42":"blob"===l&&(m=await r.oid());const w=[void 0,u,m,p],g=w.map(t=>w.indexOf(t));return g.shift(),[t,...g]}})}catch(t){throw t.caller="git.statusMatrix",t}}function Gi(){try{return oi}catch(t){throw t.caller="git.version",t}}async function Wi({fs:t,dir:e,gitdir:i=J(e,".git"),ref:r,value:s,force:n=!1,symbolic:a=!1}){try{xe("fs",t),xe("gitdir",i),xe("ref",r),xe("value",s);const e=new be(t);if(r!==w.a.clean(r))throw new Wt(r,w.a.clean(r));if(!n&&await mt.exists({fs:e,gitdir:i,ref:r}))throw new Ut("ref",r);a?await mt.writeSymbolicRef({fs:e,gitdir:i,ref:r,value:s}):(s=await mt.resolve({fs:e,gitdir:i,ref:s}),await mt.writeRef({fs:e,gitdir:i,ref:r,value:s}))}catch(t){throw t.caller="git.writeRef",t}}}).call(this,i(92).Buffer)},2049:function(t,e,i){"use strict";function r(t){return t[Symbol.asyncIterator]?t[Symbol.asyncIterator]():t[Symbol.iterator]?t[Symbol.iterator]():t.next?t:function(t){let e=[t];return{next:()=>Promise.resolve({done:0===e.length,value:e.pop()}),return:()=>(e=[],{}),[Symbol.asyncIterator](){return this}}}(t)}async function s(t){let e=0;const i=[];await async function(t,e){const i=r(t);for(;;){const{value:t,done:r}=await i.next();if(t&&await e(t),r)break}i.return&&i.return()}(t,t=>{i.push(t),e+=t.byteLength});const s=new Uint8Array(e);let n=0;for(const t of i)s.set(t,n),n+=t.byteLength;return s}var n={request:async function({onProgress:t,url:e,method:i="GET",headers:r={},body:n}){n&&(n=await s(n));const a=await fetch(e,{method:i,headers:r,body:n}),o=a.body&&a.body.getReader?function(t){if(t[Symbol.asyncIterator])return t;const e=t.getReader();return{next:()=>e.read(),return:()=>(e.releaseLock(),{}),[Symbol.asyncIterator](){return this}}}(a.body):[new Uint8Array(await a.arrayBuffer())];r={};for(const[t,e]of a.headers.entries())r[t]=e;return{url:a.url,method:a.method,statusCode:a.status,statusMessage:a.statusText,body:o,headers:r}}};e.a=n},742:function(t,e){function i(t){if(0===t.length)return".";let e=s(t);return e=e.reduce(n,[]),r(...e)}function r(...t){if(0===t.length)return"";let e=t.join("/");return e=e.replace(/\/{2,}/g,"/"),e}function s(t){if(0===t.length)return[];if("/"===t)return["/"];let e=t.split("/");return""===e[e.length-1]&&e.pop(),"/"===t[0]?e[0]="/":"."!==e[0]&&e.unshift("."),e}function n(t,e){if(0===t.length)return t.push(e),t;if("."===e)return t;if(".."===e){if(1===t.length){if("/"===t[0])throw new Error("Unable to normalize path - traverses above root directory");if("."===t[0])return t.push(e),t}return".."===t[t.length-1]?(t.push(".."),t):(t.pop(),t)}return t.push(e),t}t.exports={join:r,normalize:i,split:s,basename:function(t){if("/"===t)throw new Error(`Cannot get basename of "${t}"`);const e=t.lastIndexOf("/");return-1===e?t:t.slice(e+1)},dirname:function(t){const e=t.lastIndexOf("/");if(-1===e)throw new Error(`Cannot get dirname of "${t}"`);return 0===e?"/":t.slice(0,e)},resolve:function(...t){let e="";for(let s of t)e=s.startsWith("/")?s:i(r(e,s));return e}}}}]);